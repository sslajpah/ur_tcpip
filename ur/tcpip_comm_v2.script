def tcpip_comm_v2():
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  step_count_12503a62_4d00_45ed_87a5_22705a57ac10 = 0.0
  thread Step_Counter_Thread_7f1d4ceb_600a_40e0_8312_8f589ed05bc5():
    while (True):
      step_count_12503a62_4d00_45ed_87a5_22705a57ac10 = step_count_12503a62_4d00_45ed_87a5_22705a57ac10 + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_7f1d4ceb_600a_40e0_8312_8f589ed05bc5()
  set_target_payload(1.130000, [0.000000, 0.003000, 0.056000], [0.001887, 0.001887, 0.001887, 0.000000, 0.000000, 0.000000])
  set_gravity([0.0, 0.0, 9.82])
  set_safety_mode_transition_hardness(1)
  set_tool_communication(False, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(24)
  set_tcp(p[0.0,0.0,0.165,0.0,0.0,0.0])
  global Point_1=p[0.5673228734564902,-0.15694942793737932,0.5880304365120631,2.355554465134238,0.008459267052315513,-0.015313913082596288]
  global arucoPoS=p[0.14358606805362914,-0.5346312812726187,0.020062451119090552,-0.006999999999967311,-0.0059999999999720876,0.001999999999990575]
  global camera_point=p[0.5673249908663925,-0.15696842591057447,0.5880212097475621,2.3555427745427924,0.008487370770348553,-0.015384853854997254]
  global camera_point2=p[0.10123278156260447,-0.4515073879051816,0.4301420421424132,1.7676376582689655,-1.7499511781911048,-0.7248346176612988]
  global taskBoard=p[0.48286366852174956,0.05992883140279061,0.08331804067154605,0.002374949468008684,-0.006510387070844624,-1.5766474783914255]
  global test1=p[0.45003206386959066,-0.2999499528158499,0.20999121440538393,-3.141566624418454,-4.816541474704348E-5,1.150834355116071E-4]
  global test1plane=p[0.5146664368135077,0.04117677725515298,0.08532718099220993,-0.003603254358429996,0.0030642440845744627,-1.5683532247684813]
  global test2=p[0.44999142377706547,0.14999594978148376,0.20998821534501955,3.1415660103821974,-1.6469533416101298E-4,-1.5501713552265408E-4]
  global test2plane=p[0.32530081172265923,-0.3536937209422928,0.1672875091745058,0.005641910886239387,0.03385723378183954,-1.140209443809353]
  global transPlane=p[0.13202215668383815,-0.5497567930601044,0.019138412390539178,0.005685597373641585,-0.0019228846539893958,0.002890718331601037]
  # begin: URCap Installation Node
  #   Source: ARCS2, 2.0.3, AIRGATE ApS
  #   Type: ARCS2
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Grippers, 1.7.2.3, Robotiq Inc.
  #   Type: Vacuum
  #################################################
  # Vacuum Grip Check
  #################################################
  
  vacuumGripCheckThread1 = 0
  vacuumGripCheckThread2 = 0
  vacuumGripCheckThread3 = 0
  vacuumGripCheckThread4 = 0
  vacuumGripCheckThread1Running = False
  vacuumGripCheckThread2Running = False
  vacuumGripCheckThread3Running = False
  vacuumGripCheckThread4Running = False
  vacuumGripCheckSocketId = "1"
  vacuumGripCheckThreadStarted = False
  
  thread vacuumGripCheck():
    gripper_socket = vacuumGripCheckSocketId
    vacuumGripCheckThreadStarted = True
  
    while (True):
      objectDetectedDebounceCtr = 0
  
      while (objectDetectedDebounceCtr < 3):
        if(rq_is_vacuum_obj_detected(gripper_socket="1")):
          objectDetectedDebounceCtr = objectDetectedDebounceCtr + 1
        else:
          objectDetectedDebounceCtr = 0
        end
        sleep(0.1)
      end
  
      objectNotDetectedDebounceCtr = 0
  
      while objectNotDetectedDebounceCtr < 3:
        if (not rq_is_vacuum_obj_detected(gripper_socket="1")):
          objectNotDetectedDebounceCtr = objectNotDetectedDebounceCtr + 1
        else:
          objectNotDetectedDebounceCtr = 0
        end
        sleep(0.1)
      end
  
      socket_open("127.0.0.1",29999,"dashboardServerSocket")
      socket_send_line("pause","dashboardServerSocket")
      socket_send_string("popup Vacuum grip check has detected an object drop.", "dashboardServerSocket")
      socket_send_byte(10, "dashboardServerSocket")
      socket_close("dashboardServerSocket")
    end
  end
  
  def startVacuumGripCheckThread(gripperId="1"):
    rq_acquire_gripper_socket(gripperId)
    vacuumGripCheckSocketId = gripperId
    threadHandle = run vacuumGripCheck()
    waitForVacuumGripCheckThreadStarted()
    rq_release_gripper_socket(gripperId)
    return threadHandle
  end
  
  def stopVacuumGripCheckThread(threadHandle):
    kill threadHandle
  end
  
  def waitForVacuumGripCheckThreadStarted():
    while (not(vacuumGripCheckThreadStarted)):
      sync()
    end
    vacuumGripCheckThreadStarted = False
  end
  #################################################
  # End - Vacuum Grip Check
  #################################################
  
  #################################################
  # Stops the pump on a distance travelled
  #################################################
  global stopPumpDistance = 100
  global stopPumpSocketId = "0"
  global stopPumpThreadStarted = [False, False, False, False]
  global stopPumpThreadHandles = [0, 0, 0, 0]
  
  thread stopPumpOnDistanceTravelled():
    distance = stopPumpDistance
    socketId = stopPumpSocketId
    stopPumpThreadStarted[socket_id_index(socketId)] = True
  
    measuredDistance = waitForDistanceTravelled(distance)
  
    rq_stop(socketId)
  
    stopPumpThreadStarted[socket_id_index(socketId)] = False
  end
  
  def waitForDistanceTravelled(distance):
    startingPose = get_actual_tcp_pose()
    measuredDistance = 0
    while (measuredDistance < distance):
      sleep(0.1)
      measuredDistance = point_dist(get_actual_tcp_pose(), startingPose)
    end
  
    return measuredDistance
  end
  
  def startStopPumpOnDistanceTravelledThread(distance, gripper_socket="1"):
    if (stopPumpThreadStarted[socket_id_index(gripper_socket)]):
      return 0
    end
  
    rq_acquire_gripper_socket(gripper_socket)
    global stopPumpDistance = distance
    global stopPumpSocketId = gripper_socket
    stopPumpThreadHandles[socket_id_index(gripper_socket)] = run stopPumpOnDistanceTravelled()
    waitForStopPumpOnDistanceTravelledThreadStarted(gripper_socket)
    rq_release_gripper_socket(gripper_socket)
    return stopPumpThreadHandles[socket_id_index(gripper_socket)]
  end
  
  def waitForStopPumpOnDistanceTravelledThreadStarted(gripper_socket="1"):
    while (not(stopPumpThreadStarted[socket_id_index(gripper_socket)])):
      sync()
    end
  end
  
  def stopStopPumpOnDistanceTravelledThread(gripper_socket="1"):
    handle = stopPumpThreadHandles[socket_id_index(gripper_socket)]
    threadIsRunning = stopPumpThreadStarted[socket_id_index(gripper_socket)]
    if (threadIsRunning):
      kill handle
      clear_socket_buffer(gripper_socket, 0.01)
      stopPumpThreadHandles[socket_id_index(gripper_socket)] = 0
    end
  end
  #################################################
  # End - Stops the pump on a distance travelled
  #################################################
  
  #################################################
  # Vacuum general functions
  #################################################
  def rq_wait_for_vacuum_object_detected(gripper_socket="1"):
      while (not rq_is_vacuum_obj_detected(gripper_socket)):
          if (rq_is_vacuum_timeout(gripper_socket)):
              return False
          end
          sync()
      end
      return True
  end
  
  def rq_wait_for_vacuum_object_secured(gripper_socket="1"):
      while (not rq_is_vacuum_obj_secured(gripper_socket)):
          if (rq_is_vacuum_timeout(gripper_socket)):
              return False
          end
          sync()
      end
      return True
  end
  
  def rq_wait_for_vacuum_object_suction_complete(gripper_socket="1"):
      # Wait for suction started
      while (not rq_is_vacuum_obj_in_suction(gripper_socket) and not rq_is_vacuum_obj_detected(gripper_socket)):
          sync()
      end
  
      # Wait for suction completed
      while (rq_is_vacuum_obj_in_suction(gripper_socket)):
          if (rq_is_vacuum_timeout(gripper_socket)):
              return False
          end
          sync()
      end
  
      return True
  end
  
  def rq_wait_for_vacuum_object_not_detected(gripper_socket="1"):
      while (rq_is_vacuum_obj_detected(gripper_socket)):
          sleep(0.01)
          sync()
      end
  end
  
  def rq_is_vacuum_obj_detected(gripper_socket="1"):
      gOBJ = rq_get_var(OBJ, 1, gripper_socket)
  
      if(is_vacuum_OBJ_object_detected(gOBJ)):
          rq_obj_detect = 1
          return True
      else:
          rq_obj_detect = 0
          return False
      end
  end
  
  def rq_is_vacuum_obj_secured(gripper_socket="1"):
      gOBJ = rq_get_var(OBJ, 1, gripper_socket)
      return is_vacuum_OBJ_object_secured(gOBJ)
  end
  
  def rq_is_vacuum_obj_in_suction(gripper_socket="1"):
      gOBJ = rq_get_var(OBJ, 1, gripper_socket)
  
      if(is_vacuum_OBJ_object_in_motion(gOBJ)):
          return True
      else:
          return False
      end
  end
  
  def rq_is_vacuum_timeout(gripper_socket="1"):
    return is_FLT(6, rq_get_var(FLT, 2, gripper_socket))
  end
  
  def is_vacuum_OBJ_object_in_motion(list_of_bytes):
      # list length is not 1
      if (list_of_bytes[0] != 1):
          return False
      end
  
      # byte is '0'?
      if (list_of_bytes[1] == 48):
          return True
      end
  
      return False
  end
  
  # Returns True if list_of_byte is [1, '1'] or [1, '2']
  def is_vacuum_OBJ_object_detected(list_of_bytes):
  
      # list length is not 1
      if (list_of_bytes[0] != 1):
          return False
      end
  
      # byte is '1'?
      if (list_of_bytes[1] == 49):
          return True
      end
  
      # byte is '2'?
      if (list_of_bytes[1] == 50):
          return True
      end
  
      return False
  
  end
  
  def is_vacuum_OBJ_object_secured(list_of_bytes):
  
      # list length is not 1
      if (list_of_bytes[0] != 1):
          return False
      end
  
      # byte is '2'?
      if (list_of_bytes[1] == 50):
          return True
      end
  
      return False
  
  end
  
  def rq_set_pressure_timeout_minimum_vacuum(pressure, timeout, minimum, gripper_socket="1"):
      rq_acquire_gripper_socket(gripper_socket)
      rq_send_pos_spd_for(pressure, timeout, minimum, gripper_socket)
      ack = socket_read_byte_list(3, gripper_socket)
      rq_release_gripper_socket(gripper_socket)
  
      sync()
  
      while(is_not_ack(ack)):
          rq_acquire_gripper_socket(gripper_socket)
          rq_send_pos_spd_for(pressure, timeout, minimum, gripper_socket)
          ack = socket_read_byte_list(3, gripper_socket)
          rq_release_gripper_socket(gripper_socket)
  
          sync()
      end
  end
  
  def is_FLT(fault_number, list_of_bytes):
      zero_ascii = 48
      if (list_of_bytes[0] != 2):
          return False
      end
  
      if (list_of_bytes[1] != zero_ascii):
          return False
      end
  
      if (list_of_bytes[2] != zero_ascii + fault_number):
          return False
      end
  
      return True
  end
  
  def is_FLT_vacuum_timeout(list_of_bytes):
    return is_FLT(6, list_of_bytes)
  end
  
  def is_continuous_grip(maximum_vacuum):
    return maximum_vacuum == 0
  end
  
  def socket_id_index(socket_id):
    if (socket_id == "1"):
      return 0
    elif (socket_id == "2"):
      return 1
    elif (socket_id == "3"):
      return 2
    elif (socket_id == "4"):
      return 3
    else:
      return -1
    end
  end
  
  def rq_vacuum_release(advanced_mode=False, shutoff_distance_cm=5, wait_for_object_released=True, gripper_socket="1"):
    local shutoff_distance = scale(shutoff_distance_cm, [0, 99], [0.00, 0.99])
    local pressure = 255
    local minimum = 0
    local timeout = 255
    rq_vacuum_release_raw(advanced_mode, pressure, minimum, timeout, shutoff_distance, wait_for_object_released, gripper_socket)
  end
  
  def rq_vacuum_release_raw(advanced_mode, pressure, minimum, timeout, shutoff_distance, wait_for_object_released, gripper_socket):
    rq_reset_fault_and_activate(gripper_socket)
    rq_set_pressure_timeout_minimum_vacuum(pressure, timeout, minimum, gripper_socket)
  
    if advanced_mode:
      rq_set_gripper_mode(1, gripper_socket)
    else:
      rq_set_gripper_mode(0, gripper_socket)
    end
  
    rq_set_GTO_and_wait(1, gripper_socket)
  
    if wait_for_object_released:
      rq_wait_for_vacuum_object_not_detected(gripper_socket)
    end
  
    if advanced_mode:
      startStopPumpOnDistanceTravelledThread(shutoff_distance, gripper_socket)
    end
  end
  
  def rq_vacuum_grip(advanced_mode=False, maximum_vacuum=60, minimum_vacuum=40, timeout_ms=3000, wait_for_object_detected=True, gripper_socket="1"):
    local pressure = scale(maximum_vacuum, [0, 100], [100, 0])
    local minimum = scale(minimum_vacuum, [0, 100], [100, 0])
    local timeout = scale(timeout_ms, [0, 25500], [0, 255])
    rq_vacuum_grip_raw(advanced_mode, pressure, minimum, timeout, gripper_socket)
    if wait_for_object_detected:
      rq_wait_for_vacuum_object_suction_complete(gripper_socket)
    end
  end
  
  def rq_vacuum_grip_raw(advanced_mode, pressure, minimum, timeout, gripper_socket):
    stopStopPumpOnDistanceTravelledThread(gripper_socket)
    rq_reset_fault_and_activate(gripper_socket)
  
    rq_set_pressure_timeout_minimum_vacuum(pressure, timeout, minimum, gripper_socket)
  
    if advanced_mode:
      rq_set_gripper_mode(1, gripper_socket)
    else:
      rq_set_gripper_mode(0, gripper_socket)
    end
  
    rq_set_GTO_and_wait(1, gripper_socket)
  
  end
  
  def rq_reset_fault_and_activate(gripper_socket):
      gFLT = rq_get_var(FLT, 2, gripper_socket)
  
      if (not is_FLT_no_fault(gFLT) or not rq_is_gripper_activated(gripper_socket) or not rq_is_vacuum_obj_detected(gripper_socket)):
          rq_set_GTO_and_wait(0, gripper_socket)
          rq_set_var(ACT, 1, gripper_socket)
      end
  end
  #################################################
  # End - Vacuum general functions
  #################################################
  vacuumGripCheckWarningTitle = "Vacuum grip check"
  vacuumGripCheckWarningMessage = "Vacuum gripper object lost"
  vacuumGripTimeoutTitle = "Vacuum gripper fault"
  vacuumGripTimeoutMessage = "Grip has timed out"
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Wrist_Camera, 1.11.3.13312, Robotiq Inc.
  #   Type: Camera
  
  ###########################################
  #######Vision urcap preamble start########
  
  logging_service = rpc_factory("xmlrpc","http://127.0.0.1:4747")
  # Converts a pose relative to the flange in the base frame.
  def get_T_in_base_from_flange(T_x_in_flange):
  
    T_flange_in_base = get_actual_tool_flange_pose()
  
    T_x_in_base = pose_trans(T_flange_in_base, T_x_in_flange)
  
    return T_x_in_base
  end
  
  # Search pose cartesian (camera pose)
  T_camera_in_flange = p[0.0, 0.05, 0.05, -0.5, 0.0, 0.0]
  snapshot_position_offset = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  ignore_snapshot_position = False
  canSaveImage = False
  
  # Open connection with vision service
  xmlrpc_server=rpc_factory("xmlrpc","http://127.0.0.1:4242")
  
  # Open connection with visual offset monitor
  cam_locate_monitor=rpc_factory("xmlrpc","http://127.0.0.1:36253")
  
  # Open connection with visual offset monitor
  visual_offset_monitor=rpc_factory("xmlrpc","http://127.0.0.1:34897")
  
  #######Vision urcap preamble end##########
  ###########################################
  
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: LIFTKIT, 1.0.5, SKF Actuation System (Liestal) AG
  #   Type: LIFTKIT
  skfliftkit = rpc_factory("xmlrpc", "http://127.0.0.1:40405/RPC2")
  def liftKitReachedPosition(positionEnd, tolerance):
    local positionNow = skfliftkit.get_position()
    local upperLimit = positionEnd + tolerance
    local lowerLimit = positionEnd - tolerance
    if positionNow <= upperLimit:
      if positionNow >= lowerLimit:
        return True
      end
    end
    return False
  end
  def liftKitCheckConnection():
    if (skfliftkit.is_connected() == True):
      return True
    else:
      popup("Not connected to Liftkit. Please go to Installation.", " Not connected! ", False, True, blocking=True)
      halt
      return False
    end
  end
  def liftKitStopMotion():
    skfliftkit.move_stop()
  end
  def liftKitTriggerWdt():
    skfliftkit.trigger_watchdog("move")
  end
  def liftKitIsMoving():
    return skfliftkit.is_moving()
  end
  def get_liftkit_position():
    return skfliftkit.get_position()
  end
  def move_liftkit(liftkitPosition):
    local movingDelay = 0
    local retry = True
    while retry == True:
      retry = False
      if liftKitCheckConnection() == True:
        liftKitStopMotion()
        sleep(0.5)
        liftKitTriggerWdt()
        skfliftkit.move_to_remote_position(liftkitPosition)
        liftKitTriggerWdt()
        while liftKitReachedPosition(liftkitPosition, 1) == False and liftKitCheckConnection() == True and (liftKitIsMoving() == True  or movingDelay < 20):
          if movingDelay < 21:
            movingDelay = movingDelay + 1
          end
          liftKitTriggerWdt()
          sleep(0.1)
        end
        liftKitStopMotion()
        sleep(0.5)
      end
      if liftKitReachedPosition(liftkitPosition, 2) == False:
        popup("Pillar is not in position. Press 'Continue' to retry.", " Position Warning! ", True, False, blocking=True)
        retry = True
        movingDelay = 0
      end
    end
  end
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Copilot, 1.12.1.52, Robotiq Inc.
  #   Type: Copilot
  ###############################################################
  # Script file used to communicate with Robotiq's ft sensor
  # Version: 0.0.1
  ###############################################################

  node_rpc_server = rpc_factory("xmlrpc","http://127.0.0.1:4251/node")
  linalg = rpc_factory("xmlrpc","http://127.0.0.1:4251/linalg")
  storevar = rpc_factory("xmlrpc","http://127.0.0.1:4251/storevariable")

  global Fx = 0.0
  global Fy = 0.0
  global Fz = 0.0
  global Mx = 0.0
  global My = 0.0
  global Mz = 0.0
  global T_base_sensor = p[0,0,0,0,0,0]
  global tcp_wrench = [0,0,0,0,0,0]
  global base_wrench = [0,0,0,0,0,0]
  global rq_ft_sensor_connected = False
  global rq_active_node = 0
  global rq_elapsed_time = 0
  rq_force_protect_urcap = 0.0
  rq_torque_protect_urcap = 0.0
  rq_collision_detection_enabled = False
  rq_collision_detection_active_time = 0.0
  rq_halt_on_collision_detection = True
  sensor_wrench = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  rq_node_executor_thread_running = False

  rq_controller_time_step = get_steptime()

  def pose_to_list(p):
    return [p[0], p[1], p[2], p[3], p[4], p[5]]
  end

  def rq_init_path(pathId):
     initPathAnswer = node_rpc_server.initpath(pathId)
     verify_path_answer(initPathAnswer)
     return initPathAnswer[0]
  end

  def verify_path_answer(path_answer):
   initPathStatusCode = path_answer[1]
   handle_path_node_error_code(initPathStatusCode)
  end

  def handle_path_node_error_code(initPathStatusCode):
    if initPathStatusCode == -1:
      popup("Could not compute path with the selected options.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 1:
      popup("Joint solution impossible. Change your starting position.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 2:
      popup("Discontinuous path detected. Change your starting position.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 3:
      popup("Path time limit has been reached. Increase the speed of your path or break it down in multiple shorter paths.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 4:
      popup("Could not compute path with the selected options. Computing path timeout.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 5:
      popup("Path computation was aborted.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 6:
      popup("A previous path computation is still in progress. Please try again in a few seconds.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 7:
      textmsg("Path initialization error: Invalid path id.") # No popup needed in this case.
    end
    if initPathStatusCode != 0:
      halt
    end
  end


  def rq_wait_ft_sensor_steady(timeout = 2000):

    max_mean_squared_error = [0.1, 0.1, 0.1, 0.0001, 0.0001, 0.0001]
    mean = sensor_wrench

    mean_squared_error = sensor_wrench
    i=0
    while i<6:
      mean_squared_error[i] = mean_squared_error[i] * mean_squared_error[i]
      i=i+1
    end

    is_sensor_steady = False
    alpha = 0.9
    timer = 0

    while (not is_sensor_steady) and (timer < timeout):
      sleep(0.008)
      timer = timer + 8

      i = 0
      while i < 6:
        mean[i] = alpha * mean[i] + (1.0 - alpha) * sensor_wrench[i]
        error = sensor_wrench[i] - mean[i]
        mean_squared_error[i] = alpha * mean_squared_error[i] + ((1.0 - alpha) * error * error)
        i = i+1
      end

      is_sensor_steady = True
      i = 0
      while (i < 6) and is_sensor_steady:
        is_sensor_steady = mean_squared_error[i] < max_mean_squared_error[i]
        i = i+1
      end
    end

    return is_sensor_steady
  end

  thread rq_elapsed_timer_ms():
    rq_elapsed_time = 0
  dt = 1000/500
    while True:
      rq_elapsed_time =  rq_elapsed_time + dt
      sync()
    end
  end

  def get_sensor_fx():
    return Fx
  end

  def get_sensor_fy():
    return Fy
  end

  def get_sensor_fz():
    return Fz
  end

  def get_sensor_mx():
    return Mx
  end

  def get_sensor_my():
    return My
  end

  def get_sensor_mz():
    return Mz
  end

  def get_applied_tcp_force(index):
    return -1.0 * tcp_wrench[index]
  end

  def get_applied_base_force(index):
    return -1.0 * base_wrench[index]
  end

  def express_vector_in_new_frame(T_from_to, V_from):
    Q_from_to = p[0, 0, 0, T_from_to[3], T_from_to[4], T_from_to[5]]
    V_to = pose_trans(pose_inv(Q_from_to), p[V_from[0], V_from[1], V_from[2], 0, 0, 0])
    return [V_to[0], V_to[1], V_to[2]]
  end

  def express_force_in_frame(T_from_to, wrench_from):
    F = express_vector_in_new_frame(T_from_to, [wrench_from[0], wrench_from[1], wrench_from[2]])
    T = express_vector_in_new_frame(T_from_to, [wrench_from[3], wrench_from[4], wrench_from[5]])
    return [F[0], F[1], F[2], T[0], T[1], T[2]]
  end

  thread read_force():


    if (not socket_open("127.0.0.1", 29999, "RQDashboardClient")):
      popup("Can't connect to the Dashboard server", "Robotiq's FT Sensor", error=True)
      halt
    end

    rq_collision_detection_active_count = 0
    rq_collision_detection_active = False

    while True:

        T_base_tcp = get_actual_tcp_pose()
        T_base_flange = get_actual_tool_flange_pose()
        T_flange_sensor = p[0, 0, 0, 0, 0, 0]
        T_base_sensor = pose_trans(T_base_flange, T_flange_sensor)

        T_flange_tcp = pose_trans( pose_inv(T_base_flange), T_base_tcp)
        T_sensor_tcp = pose_trans( pose_inv(T_flange_sensor), T_flange_tcp)

        sensor_wrench = express_force_in_frame(T_base_sensor, get_tcp_force())
        tcp_wrench = wrench_trans(pose_inv(T_sensor_tcp), sensor_wrench)
        base_wrench = express_force_in_frame(pose_inv(T_base_tcp), tcp_wrench)

        Fx = sensor_wrench[0]
        Fy = sensor_wrench[1]
        Fz = sensor_wrench[2]
        Mx = sensor_wrench[3]
        My = sensor_wrench[4]
        Mz = sensor_wrench[5]

        write_output_float_register(TCP_FX_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[0])
        write_output_float_register(TCP_FY_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[1])
        write_output_float_register(TCP_FZ_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[2])
        write_output_float_register(TCP_MX_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[3])
        write_output_float_register(TCP_MY_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[4])
        write_output_float_register(TCP_MZ_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[5])

        if rq_collision_detection_enabled:
            if rq_collision_detection_active_time < (0.5*rq_controller_time_step):
                if norm([Fx, Fy, Fz]) > rq_force_protect_urcap:
                    rq_on_collision_detection("Force limit value exceeded.")
                elif norm([Mx, My, Mz]) > rq_torque_protect_urcap:
                    rq_on_collision_detection("Torque limit value exceeded.")
                end
            else:
                rq_collision_detection_active_time = rq_collision_detection_active_time + rq_controller_time_step
                if rq_collision_detection_active_time >= 1.0:
                    rq_collision_detection_active_time = 0.0
                end
            end
        end

        sync()

    end
  end

  def rq_get_ft_sensor_state():
    socket_open("127.0.0.1",63350,"rq_ft_sensor_state")
    socket_send_string("CURRENT STATE", "rq_ft_sensor_state")
    rq_sensor_state = socket_read_string("rq_ft_sensor_state")
    socket_close("rq_ft_sensor_state")

    if rq_sensor_state == "":
      rq_sensor_state = "RQ_STATE_INIT"
    end

    return rq_sensor_state
  end

  def rq_ft_sensor_disconnected_warn_user():
    socket_open("127.0.0.1",29999,"SensorWarning")
    socket_send_string("popup FT Sensor must be connected to run this program.","SensorWarning")
    socket_send_byte(10,"SensorWarning")
    socket_close("SensorWarning")
  end

  def rq_ft_sensor_disconnected_stop_program():
    socket_open("127.0.0.1", 30002, "rq_ft_sensor_stop_socket")

    socket_send_string("def rq_ft_sensor_stop_program():", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")
    socket_send_string("  stopj(5.0)", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")
    socket_send_string("end", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")

    socket_close("rq_ft_sensor_stop_socket")
  end

  def rq_ft_sensor_disconnected_check():
    if rq_get_ft_sensor_state() == "RQ_STATE_INIT":
      rq_ft_sensor_disconnected_stop_program()
      rq_ft_sensor_disconnected_warn_user()

      return True
    else:
      return False
    end
  end

  #RTDE input registers
  TARGET_JOINT_0_INPUT_REGISTER_DOUBLE = 40
  TARGET_JOINT_1_INPUT_REGISTER_DOUBLE = 41
  TARGET_JOINT_2_INPUT_REGISTER_DOUBLE = 42
  TARGET_JOINT_3_INPUT_REGISTER_DOUBLE = 43
  TARGET_JOINT_4_INPUT_REGISTER_DOUBLE = 44
  TARGET_JOINT_5_INPUT_REGISTER_DOUBLE = 45
  FINISH_NODE_INPUT_REGISTER_INT32 = 40
  LICENSING_ERROR_INPUT_REGISTER_INT32 = 41
  ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32 = 42

  #RTDE output registers
  ACTIVE_NODE_OUTPUT_REGISTER_INT32 = 0
  NODE_EXECUTION_OUTPUT_COUNT_INT32 = 1
  ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32 = 2
  TCP_FX_ACTUAL_OUTPUT_DOUBLE = 0
  TCP_FY_ACTUAL_OUTPUT_DOUBLE = 1
  TCP_FZ_ACTUAL_OUTPUT_DOUBLE = 2
  TCP_MX_ACTUAL_OUTPUT_DOUBLE = 3
  TCP_MY_ACTUAL_OUTPUT_DOUBLE = 4
  TCP_MZ_ACTUAL_OUTPUT_DOUBLE = 5
  GENERAL_OUTPUT_DOUBLE_6 = 6
  GENERAL_OUTPUT_DOUBLE_7 = 7
  GENERAL_OUTPUT_DOUBLE_8 = 8
  GENERAL_OUTPUT_DOUBLE_9 = 9
  GENERAL_OUTPUT_DOUBLE_10 = 10
  GENERAL_OUTPUT_DOUBLE_11 = 11

  write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, 0)
  write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, 0)
  write_output_integer_register(ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32, 0)
  write_output_float_register(TCP_FX_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_FY_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_FZ_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MX_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MY_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MZ_ACTUAL_OUTPUT_DOUBLE, 0)

  global activation_node_count = 0
  global node_execution_count = 0

  def element_wise_subtract(l1, l2):
    global r = l1
    i=0
    while i<length(r):
      r[i]=l1[i]-l2[i]
      i=i+1
    end
    return r
  end

  def list_by_scalar_multiply(l1, scalar):
      global r = l1
      i=0
      while i<length(r):
        r[i]=l1[i]*scalar
        i=i+1
      end
      return r
   end

  def norm_inf(v):
    norm = 0
    i=0
    while i<length(v):
        n = norm(v[i])
        if(n > norm):
          norm = n
        end
      i=i+1
    end
    return norm
  end

  def active_and_reset_node(nodeId):
    server_activation_node_count = read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32)

    activation_node_count = activation_node_count + 1
    node_execution_count = 0
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    rq_active_node = nodeId
    write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, nodeId)
    write_output_integer_register(ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32, activation_node_count)

    while server_activation_node_count == read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32):
      sync()
    end
  end

  def execute_node(nodeId, startThread = False):
    node_execution_thread = 0
    active_and_reset_node(nodeId)
    if startThread:
      movej(get_actual_joint_positions()) # This moveJ is used to prevent "another thread is already controlling the robot error".
                                          # In some occasions, even a sleep(0.05) will not work so this is necessary (until fixed by UR).
      node_execution_thread = run execute_node_thread()
    end
    while not active_node_completed():
      sync()
    end
    return node_execution_thread
  end

  def setup_node_execution_related_variables():
    activation_node_count = 0
    node_execution_count = 0
    write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, 0)
    write_output_integer_register(ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32, activation_node_count)
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    sync()
  end

  def start_node_executor():
    setup_node_execution_related_variables()

    succeeded = node_rpc_server.startnodeexecutor()
    if not succeeded:
      node_rpc_server.stopnodeexecutor()
      succeeded = node_rpc_server.startnodeexecutor()
      if not succeeded:
        popup("RTDE interface cannot initialize. Make sure that Ethernet/IP adapter and Profinet are disabled, and that no other URCaps use the RTDE interface.", "Robotiq Copilot", error=True)
        halt
      end
    end

    hand_shake_xmlrpcserver()
  end

  def reset_node_executor():
    setup_node_execution_related_variables()

    succeeded = node_rpc_server.resetnodeexecutor()
    if not succeeded:
      popup("RTDE interface cannot initialize. Make sure that Ethernet/IP adapter and Profinet are disabled, and that no other URCaps use the RTDE interface.", "Robotiq Copilot", error=True)
      halt
    end

    hand_shake_xmlrpcserver()
  end

  def hand_shake_xmlrpcserver():
    timer_thread = run rq_elapsed_timer_ms()
    sync()
    node_execution_initialized = False
    while (not node_execution_initialized) and (rq_elapsed_time < 100):
      node_execution_initialized = (read_input_integer_register(FINISH_NODE_INPUT_REGISTER_INT32) == -1)
      sync()
    end
    kill timer_thread

    if (not node_execution_initialized):
      popup("Node Execution initialization failed.", "Robotiq Copilot", error=True)
      halt
    end
  end

  thread execute_node_thread():
    joint_target_positions_prev = get_actual_joint_positions()
    servoj(joint_target_positions_prev)
    while True:
      joint_target_position = update_target_position()
      joint_target_distances = element_wise_subtract(joint_target_positions_prev, joint_target_position)
      max_joint_target_displacement = norm_inf(joint_target_distances)
      if max_joint_target_displacement > 0.2:
          textmsg("previous target position: ", joint_target_positions_prev)
          textmsg("next target position: ", joint_target_position)
          textmsg("max joint target displacement: ", max_joint_target_displacement)
          popup(max_joint_target_displacement, "Node Executor Error", False, True, True)
          halt
      end
      servoj(joint_target_position, t=0.008, lookahead_time=0.05, gain=500)
      joint_target_positions_prev = joint_target_position
    end
  end

  def kill_thread( thread_id ):
    kill thread_id
    movej(get_actual_joint_positions()) # This moveJ is used to prevent "another thread is already controlling the robot error".
                                        # In some occasions, even a sleep(0.05) will not work so this is necessary (until fixed by UR).
                                        # This function should also be used for other nodes (e.g. Path, RobotiqMove, PathGenerator) if they cause the ‘another thread…’ error.
  end

  def active_node_completed():
    return (read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32) == activation_node_count) and
           (read_input_integer_register(FINISH_NODE_INPUT_REGISTER_INT32) == rq_active_node)
  end

  def update_target_position():

    if read_input_integer_register(LICENSING_ERROR_INPUT_REGISTER_INT32):
        popup("Robotiq license error!", "Robotiq Copilot", error=True)
        halt
    end

    joint_target_position = [0,0,0,0,0,0]
    joint_target_position[0] = read_input_float_register(TARGET_JOINT_0_INPUT_REGISTER_DOUBLE)
    joint_target_position[1] = read_input_float_register(TARGET_JOINT_1_INPUT_REGISTER_DOUBLE)
    joint_target_position[2] = read_input_float_register(TARGET_JOINT_2_INPUT_REGISTER_DOUBLE)
    joint_target_position[3] = read_input_float_register(TARGET_JOINT_3_INPUT_REGISTER_DOUBLE)
    joint_target_position[4] = read_input_float_register(TARGET_JOINT_4_INPUT_REGISTER_DOUBLE)
    joint_target_position[5] = read_input_float_register(TARGET_JOINT_5_INPUT_REGISTER_DOUBLE)

    node_execution_count = node_execution_count + 1
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    return joint_target_position
  end

  def set_servoj_node_cmd(q):
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_6, q[0])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_7, q[1])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_8, q[2])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_9, q[3])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_10, q[4])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_11, q[5])
  end

  def rq_collision_detection_start(force_limit = 140, torque_limit = 14, halt_on_collision = True):
    rq_force_protect_urcap = force_limit
    rq_torque_protect_urcap = torque_limit
    rq_collision_detection_active_time = 0.0
    rq_collision_detection_enabled = True
    rq_halt_on_collision_detection = halt_on_collision
  end

  def rq_collision_detection_stop():
    rq_collision_detection_enabled = False
  end

  def rq_on_collision_detection(message):
    textmsg("Collision Detection. " + message)
    popupTitle = "Collision Detection"
    if rq_halt_on_collision_detection:
      popup(message + " Program halt.", popupTitle, False, True, False)
      halt
    else:
      popup(message + " Program suspend.", popupTitle, True, False, False)
      socket_send_line("pause", "RQDashboardClient")
      rq_collision_detection_active_time = rq_controller_time_step
    end
  end

  ################################
  # MAIN
  ################################

  run read_force()
  start_node_executor()
  
  #***********************************************************************************************
  # verify tap detection
  #***********************************************************************************************
  
  def rq_tap_count(forces, high_threshold):
  
    low_threshold = 2
    tapCount = 0
    lookingForPeak = True
    indexDown = 0
  
    i = 1
    lastIndex = length(forces) - 1
    while i <= lastIndex:
  
      deltaForce = forces[i] - forces[0]
  
     if lookingForPeak:
        if deltaForce >  high_threshold:
          lookingForPeak = False
        end
      else:
        if deltaForce < low_threshold:
          tapCount = tapCount + 1
          lookingForPeak = True
          indexDown = i
        end
      end
      i = i + 1
  
    end
  
    if indexDown != lastIndex:
      tapCount = 0
    end
  
    return tapCount
  
  end
  def shift_right(list, default_value = 0):
  
     i = length(list)-1
     while (i > 0):
        list[i]=list[i-1]
        i=i-1
     end
     list[0] = default_value
  
     return list
  end
  
  #***********************************************************************************************
  # Wait for force reached
  #***********************************************************************************************
  # desired_wrench : desired wrench
  # is_active      : list of 0 and 1, 1 : axis is controlled
  # feature        : 0:base, 1:tcp
  # timeout        : timeout in miliseconds
  #***********************************************************************************************
  def rq_wait_for_force_reached(desired_wrench, is_active, feature, timeout):
  
    feature_base = 0
    feature_tool = 1
    time_constant = 0.025
    alpha = 1 - pow(2.718, -1.0 * get_steptime() / time_constant)
  
    thresholds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    minimal_thresholds = [1.0, 1.0, 1.0, 0.1, 0.1, 0.1]
  
    applied_wrench = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    filtered_wrench = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  
    if (feature == feature_base):
      applied_wrench = list_by_scalar_multiply(base_wrench, -1.0)
    else:
      applied_wrench = list_by_scalar_multiply(tcp_wrench, -1.0)
    end
    filtered_wrench = applied_wrench
  
    i = 0
    while (i < 6):
      if (is_active[i]):
        thresholds[i] = 0.05 * norm(desired_wrench[i])
        if thresholds[i] < minimal_thresholds[i]:
          thresholds[i] = minimal_thresholds[i]
        end
      else:
        thresholds[i] = 10000
      end
      i = i+1
    end
  
   force_reached = False
  
   timer = 0
  
   while ((not force_reached) and (timer < timeout)):
  
      if (feature == feature_base):
         applied_wrench = list_by_scalar_multiply(base_wrench, -1.0)
      else:
         applied_wrench = list_by_scalar_multiply(tcp_wrench, -1.0)
      end
  
      i = 0
      while (i < 6):
        filtered_wrench[i] = (alpha * applied_wrench[i]) + ((1.0 - alpha) * filtered_wrench[i])
        i = i+1
      end
  
      force_reached = True
  
      i = 0
      while ((i < 6) and force_reached):
        error = norm(desired_wrench[i] - filtered_wrench[i])
        if (error > thresholds[i]):
          force_reached = False
        end
        i = i + 1
      end
  
      timer = timer + get_steptime()
  
      sync()
  
    end
  
    return force_reached
  end
  #***********************************************************************************************
  # verify click detection
  #***********************************************************************************************
  click_detection_children_ended = False
  
  def rq_click_detection(force_drop_threshold = 10, torque_drop_threshold = 1, force_radio_button_selected = True):
  
    current_norm = 0
    drop_threshold = 0
    norms = [0.0, 0.0, 0.0, 0.0, 0.0]
    click_detected = False
    wrench_indices = [0,0,0]
  
    if(force_radio_button_selected):
      drop_threshold = force_drop_threshold
      wrench_indices = [0,1,2]
    else:
      drop_threshold =torque_drop_threshold
      wrench_indices = [3,4,5]
    end
  
    while ((not click_detection_children_ended) and (not click_detected)):
  
      current_norm = norm([sensor_wrench[wrench_indices[0]], sensor_wrench[wrench_indices[1]], sensor_wrench[wrench_indices[2]]])
  
      norms[4] = norms[3]
      norms[3] = norms[2]
      norms[2] = norms[1]
      norms[1] = norms[0]
      norms[0] = current_norm
  
      avg_norm = (norms[2] + norms[3] + norms[4]) / 3.0
  
      #Check if clicking is detected with force
      norm_drop = avg_norm - current_norm
      if(norm_drop > drop_threshold):
        textmsg("Click detected")
        click_detected=True
      else:
        sleep(0.008)
      end
    end
  
    return click_detected
  end
  ###############################################################
  # Script file used to define Robotiq functions for the Insertion node
  # Version: 0.0.2
  ###############################################################
  
  rq_ins_offset = p[0, 0, 0, 0, 0, 0]
  rq_ins_start_pose = p[0, 0, 0, 0, 0, 0]
  rq_actual_to_destination = p[0, 0, 0, 0, 0, 0]
  rq_ins_destination =p[0, 0, 0, 0, 0, 0]
  rq_ins_speed_setting = 0
  rq_rotation_not_completed = False
  rq_find_bottom_not_completed = False
  rq_spiral_not_completed = False
  
  def ins_actual_force_urcap(direction="X+"):
    axis = str_at(direction, 0)
    if (axis == "x") or (axis == "X"):
      return norm(get_applied_tcp_force(0))
    elif (axis == "y") or (axis == "Y"):
      return norm(get_applied_tcp_force(1))
    elif (axis == "z") or (axis == "Z"):
      return norm(get_applied_tcp_force(2))
    else:
      textmsg("ins_actual_force_urcap, invalid direction ", direction)
    end
  end
  
  def ins_actual_torque_urcap(direction = "Z+"):
    if (direction == "X+") or (direction == "X-") or (direction == "X"):
      return get_applied_tcp_force(3)
    elif (direction == "Y+") or (direction == "Y-") or (direction == "Y"):
      return get_applied_tcp_force(4)
    else:
      return get_applied_tcp_force(5)
    end
  
  end
  
  def square(a):
    return a*a
  end
  
  def update_servoj_node_target(target_joint_pos):
    set_servoj_node_cmd(target_joint_pos)
    sync()
  end
  
  def create_all_insertion_nodes():
    global rq_insertion_force_node_id = node_rpc_server.createnewforcenode()
    global rq_insertion_movej_node_id = node_rpc_server.createnewmovejnode()
    global rq_insertion_servoj_node_id = node_rpc_server.createnewservojnode()
    node_rpc_server.setparentid(rq_insertion_movej_node_id, rq_insertion_force_node_id)
    node_rpc_server.setparentid(rq_insertion_servoj_node_id, rq_insertion_force_node_id)
  end
  
  def setup_force_node_on_server(generic_rq_insertion_force_node_id = 1,
                                 feature=1,
                                 targetforce = [0,0,0,0,0,0],
                                 force_control_enabled_axes = [False, False, False, False, False, False],
                                 max_negative_deviation_vector = [-0.1, -0.1, -0.1, -0.1, -0.1, -0.1],
                                 max_positive_deviation_vector = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1],
                                 adaptiveStiffness = True):
    node_rpc_server.setforcecontrolfeature(generic_rq_insertion_force_node_id, feature)
    node_rpc_server.setforcecontroltargetforce(generic_rq_insertion_force_node_id, targetforce)
    node_rpc_server.setforcecontrolenabledaxes(generic_rq_insertion_force_node_id, force_control_enabled_axes)
    node_rpc_server.setforcecontrolmaximaldeviation(generic_rq_insertion_force_node_id, max_negative_deviation_vector, max_positive_deviation_vector)
    node_rpc_server.setforcecontroladaptivestiffnessenabledaxes(generic_rq_insertion_force_node_id, True)
  end
  
  def get_offset_projected_in_spiral_plane(direction, current_pose, pose_ref):
    axis = str_at(direction, 0)
    axis_index = 0
    if axis == "X":
      axis_index = 0
    elif axis == "Y":
      axis_index = 1
    elif axis == "Z":
      axis_index = 2
    else:
      textmsg("get_offset_projected_in_spiral_plane, invalid direction ", direction)
    end
  
    pose_offset = pose_trans(current_pose, pose_inv(pose_ref))
  
    pose_offset[axis_index] = 0 # valeur en direction mise a zero
    pose_offset[3] = 0 # valeur en Rx mise a zero
    pose_offset[4] = 0 # valeur en Ry mise a zero
    pose_offset[5] = 0 # valeur en Rz mise a zero
  
    return pose_offset
  end
  
  def update_spiral_offset(direction, spiral_initial_pose, spiral_initial_pose_offset, spiral_initial_pose_offset_name):
    pos_diff_tcp = get_offset_projected_in_spiral_plane(direction, get_actual_tcp_pose(), spiral_initial_pose)
    spiral_initial_pose_offset = interpolate_pose(spiral_initial_pose_offset, pos_diff_tcp, 0.35)
    storevar.setvariable(spiral_initial_pose_offset_name, spiral_initial_pose_offset)
  end
  
  def determine_max_spiral_radius_from_actual_position(direction, spiral_initial_pose, max_radius):
      dist_to_initial_pose = norm( get_offset_projected_in_spiral_plane(direction, get_actual_tcp_pose(), spiral_initial_pose))
      if (max_radius > dist_to_initial_pose):
        new_max_radius = max_radius - dist_to_initial_pose
      else:
        new_max_radius = 0
      end
  
      return new_max_radius
  end
  
  def insertion_compliant_move_urcap(axis = "Z",
                                     direction_sign = 1,
                                     compliant_insert_force_threshold = 20,
                                     speed = 0.04,
                                     feature = 1,
                                     max_position_deviation = 0.1):
    feature_base = 0
    feature_tool = 1
  
    if axis == "X":
      axis_index = 0
    elif axis == "Y":
      axis_index = 1
    elif axis == "Z":
      axis_index = 2
    else:
      textmsg("insertion_compliant_move_urcap, invalid direction ", axis)
    end
  
    current_pose = get_actual_tcp_pose()
    insertion_offset = p[0,0,0,0,0,0]
    rq_actual_to_destination = pose_trans(pose_inv(current_pose), rq_ins_destination)
    insertion_offset[axis_index] = rq_actual_to_destination[axis_index]
    insertion_pose = pose_trans(current_pose, insertion_offset)
    distance = point_dist(current_pose, insertion_pose)
    number_of_steps = floor( distance / (speed * get_steptime()) ) + 1
    alpha_step  = 1.0 / number_of_steps
  
    # initialize forcenode
    node_execution_thread = initialise_force_node(position_controlled_direction = axis_index,
                                                  feature = feature_tool,
                                                  max_position_deviation = max_position_deviation)
  
    alpha = 0.0
    surface_found = False
    while (alpha <= 1.0) and (not surface_found):
      alpha = alpha + alpha_step
      interpolated_pose = interpolate_pose(current_pose, insertion_pose, alpha)
      q0 = get_inverse_kin(interpolated_pose) # define waypoint target
      update_servoj_node_target(q0)
      force = 0
      if feature == feature_base:
        force = get_applied_base_force(axis_index)
      elif feature == feature_tool:
        force = get_applied_tcp_force(axis_index)
      end
      if (direction_sign * force) >= compliant_insert_force_threshold:
        surface_found = True
      end
    end
  
    final_pos_reached = (alpha >= 1)
  
    kill_thread( node_execution_thread )
  
    return final_pos_reached
  end # insertion_compliant_move_urcap
  
  def insert_spiral_find_hole(axis = "Z", direction_sign = 1,
                              stop_force_threshold = 3,
                              max_radius = 0.005,
                              radius_incr_per_turn = 0.0003,
                              peck_mode = False,
                              tangential_speed = 0.005):
  
    if (stop_force_threshold < 0) or (stop_force_threshold > 40):
      popup("stop_force_threshold parameter in Newton must be between 0 and 40 Newtons","ERROR rq_insert_spiral_urcap")
      halt
    end
    if (max_radius < 0) or (max_radius > 0.05):
      popup("max_radius parameter must be between 0 mm and 50 mm","ERROR rq_insert_spiral_urcap")
      halt
    end
    if (radius_incr_per_turn < 0.00001) or (radius_incr_per_turn > 0.005):
      popup("radius_incr_per_turn parameter in mm must be between 0.01 mm and 5 mm","ERROR rq_insert_spiral_urcap")
      halt
    end
  
    rq_spiral_not_completed = False
  
    ins_x = 0
    ins_y = 0
    ins_z = 0
    ins_pose = p[0, 0, 0, 0, 0, 0]
    ins_current_pos = p[0, 0, 0, 0, 0, 0]
    ins_actual_angle = 0
    ins_search_result = False
    ins_radius_offset = 0
    ins_PI = 3.14159
    radius_inc_per_rad = radius_incr_per_turn / (2*ins_PI)
    ins_actual_radius = 0.0001  #Start radius
    ins_desired_arc_length = tangential_speed * rq_controller_time_step
  
    sync()
    #Find the bore of the part
    ins_current_pos = get_actual_tcp_pose()
    sync()
  
    # if axis == "Z"
    search_axis = 2
    other_axis_A = 0
    other_axis_B = 1
    if (axis == "X"):
      search_axis = 0
      other_axis_A = 2
      other_axis_B = 1
    elif (axis == "Y"):
      search_axis = 1
      other_axis_A = 0
      other_axis_B = 1
    end
  
    #********************************************************************************************************************
    #Spiral Search using any Axis
    #********************************************************************************************************************
    while ((ins_actual_radius <= max_radius) and (ins_actual_force_urcap(axis) >= stop_force_threshold)):
      if peck_mode:
        #Fragile mode, the robot rises between each new point
        #Retreat from position
        ins_pose[search_axis] = -0.002 * direction_sign
        next_tcp_pose = pose_trans(ins_current_pos,ins_pose)
        movej(next_tcp_pose)
        sleep(0.1)
        #Rotate
        ins_desired_arc_length = 0.0005
        delta_angle = ins_desired_arc_length / ins_actual_radius #small angle approximation
        ins_actual_angle = ins_actual_angle + delta_angle
  
        ins_pose[other_axis_A] = cos( ins_actual_angle ) * ins_actual_radius
        ins_pose[other_axis_B] = sin( ins_actual_angle ) * ins_actual_radius
  
        ins_actual_radius = ins_actual_angle * radius_inc_per_rad + ins_radius_offset
        next_tcp_pose = pose_trans(ins_current_pos, ins_pose)
        movej(next_tcp_pose)
        sleep(0.1)
        #Re-establish contact with the part
        ins_pose[search_axis] = 0.0005 * direction_sign
        next_tcp_pose = pose_trans(ins_current_pos, ins_pose)
        movel(next_tcp_pose, a=0.6, v=rq_ins_speed_setting)
        sleep(0.2)
      else:
        #standard mode: the Spiral_Search function will maintain contact between both mating parts at all times
        ins_pose[other_axis_A] = cos( ins_actual_angle ) * ins_actual_radius
        ins_pose[other_axis_B] = sin( ins_actual_angle ) * ins_actual_radius
  
        delta_angle = ins_desired_arc_length / ins_actual_radius
        ins_actual_angle = ins_actual_angle + delta_angle
        ins_actual_radius = ins_actual_angle * radius_inc_per_rad + ins_radius_offset
        next_tcp_pose = pose_trans(ins_current_pos,ins_pose)
        next_joint_pos = get_inverse_kin(next_tcp_pose)
        servoj(next_joint_pos, 0.1, 0.1, rq_controller_time_step, 0.05, 500)
      end
    end # while loop
    if (ins_actual_radius <= max_radius ):
      ins_search_result = True
    else:
      ins_search_result = False
      rq_spiral_not_completed = True
    end
    stopj(2)
    return ins_search_result
  
  end # insert_spiral_find_hole
  
  def rq_insert_spiral_urcap(direction = "Z",
                             stop_force_threshold = 3,
                             max_radius = 0.005,
                             radius_incr = 0.0003,
                             peck_mode = False,
                             tangential_speed = 0.005,
                             compliant_insert_force_threshold = 10,
                             spiral_initial_pose_offset_name = "defaultname",
                             intelligent_approach_enabled = False):
  
    max_radius = max_radius / 1000 #TODO: change unit to meters and remove this line
    radius_incr = radius_incr / 1000 #TODO: change unit to meters and remove this line
  
    if (rq_insertion_force_node_id == -1):
      create_all_insertion_nodes()
    end
  
    hole_found = False
    spiral_bottom_target_reached = False
    number_of_failed_spiral_tries = 0
    number_of_spiral_tries_max = 5
    max_position_deviation = max_radius
  
    # define the direction sign from rq_ins_destination
    current_pose = get_actual_tcp_pose()
    rq_actual_to_destination = pose_trans(pose_inv(current_pose), rq_ins_destination)
    axis = str_at(direction, 0)
    direction_sign = 1
    direction = str_cat(axis,"+")
    if axis == "X":
      axis_index = 0
    elif axis == "Y":
      axis_index = 1
    elif axis == "Z":
      axis_index = 2
    else:
      textmsg("spiral insert, invalid direction ", direction)
    end
    if (rq_actual_to_destination[axis_index] < 0):
      direction_sign = -1
      direction = str_cat(axis,"-")
    end
  
    # linearsearch param
    lin_search_stop_force_threshold = compliant_insert_force_threshold
    spiral_initial_pose = get_actual_tcp_pose()
    if intelligent_approach_enabled:
      #adjust position using previous succesfull insertion final position
      spiral_initial_pose_offset = storevar.getvariable(spiral_initial_pose_offset_name, p[0,0,0,0,0,0])
      spiral_initial_pose_refined = pose_trans(spiral_initial_pose, spiral_initial_pose_offset)
      movel(spiral_initial_pose_refined, a = 0.1, v = 0.01)
      sleep(0.01)
    end
    while ( (spiral_bottom_target_reached == False) and (number_of_failed_spiral_tries < number_of_spiral_tries_max) ):
      rq_actual_to_destination = pose_trans(pose_inv(get_actual_tcp_pose()), rq_ins_destination)
      max_distance = norm( rq_actual_to_destination[axis_index] )
      contact_initiated = rq_linear_search_urcap(direction, lin_search_stop_force_threshold, tangential_speed, max_distance, 1)
      if contact_initiated:
        new_max_radius = determine_max_spiral_radius_from_actual_position(direction, spiral_initial_pose, max_radius)
        hole_found = insert_spiral_find_hole(axis, direction_sign, stop_force_threshold, new_max_radius, radius_incr, peck_mode, tangential_speed)
        if (hole_found == True): # if hole is found, try to insert
          max_force_control_position_deviation = determine_max_spiral_radius_from_actual_position(direction, spiral_initial_pose, max_radius)
          spiral_bottom_target_reached = insertion_compliant_move_urcap(axis, direction_sign, compliant_insert_force_threshold, tangential_speed, 1, max_force_control_position_deviation)
          if spiral_bottom_target_reached:
            if intelligent_approach_enabled:
              update_spiral_offset(direction, spiral_initial_pose, spiral_initial_pose_offset, spiral_initial_pose_offset_name) # update actual hole position.
            end
          else:
            textmsg("Insertion spiral: could not reach hole bottom")
          end
        else:
          textmsg("Insertion error: hole was not found after contact")
          break
        end
      else: # linear_search reached the teach position without contact
          spiral_bottom_target_reached = True
      end # if contact_initiated
      number_of_failed_spiral_tries = number_of_failed_spiral_tries + 1
    end # while
    return (not spiral_bottom_target_reached)
  end # rq_insert_spiral_urcap
  
  def insertion_finish_move_urcap(direction = "Z+"):
    insertion_offset = p[0,0,0,0,0,0]
    current_pose = get_actual_tcp_pose()
    rq_actual_to_destination = pose_trans(pose_inv(current_pose), rq_ins_destination)
    axis = str_at(direction, 0)
    if axis == "X":
      insertion_offset = p[rq_actual_to_destination[0],0,0,0,0,0]
    elif axis == "Y":
      insertion_offset = p[0,rq_actual_to_destination[1],0,0,0,0]
    elif axis == "Z":
      insertion_offset = p[0,0,rq_actual_to_destination[2],0,0,0]
    else:
      textmsg("insertion_finish_move_urcap, invalid direction ", direction)
    end
    insertion_pose = pose_trans(current_pose, insertion_offset)
    movel(insertion_pose, a=0.05, v=rq_ins_speed_setting)
  end
  
  def rq_xor(a, b):
    return (a and not(b)) or (not(a) and b)
  end
  
  def rq_adapt_force_control_to_direction(position_controlled_direction = 2, feature = 1, max_position_deviation = 0.1):
    force_control_enabled_vector = [True, True, True, False, False, False]
    force_control_enabled_vector[position_controlled_direction] = False
    targetForce = [0, 0, 0, 0, 0, 0]
    max_negative_deviation_vector = [-max_position_deviation, -max_position_deviation, -max_position_deviation, 0, 0, 0]
    max_positive_deviation_vector = [max_position_deviation, max_position_deviation, max_position_deviation, 0, 0, 0]
    max_negative_deviation_vector[position_controlled_direction] = 0
    max_positive_deviation_vector[position_controlled_direction] = 0
    adaptiveStiffness = True
    setup_force_node_on_server(rq_insertion_force_node_id,
                               feature, targetForce,
                               force_control_enabled_vector,
                               max_negative_deviation_vector,
                               max_positive_deviation_vector,
                               adaptiveStiffness)
  end
  
  def initialise_force_node(position_controlled_direction = 2, feature = 1, max_position_deviation = 0.1):
    movej(get_actual_joint_positions()) # This moveJ is used to prevent "another thread is already controlling the robot error".
    rq_adapt_force_control_to_direction(position_controlled_direction = position_controlled_direction,
                                        feature = 1,
                                        max_position_deviation = max_position_deviation)
    set_servoj_node_cmd(get_actual_joint_positions())
    reset_node_executor()
    active_and_reset_node(rq_insertion_force_node_id)
    active_and_reset_node(rq_insertion_servoj_node_id)
    node_execution_thread = run execute_node_thread()
    return node_execution_thread
  end
  
  def rq_insert_rotation_urcap(positive_rotation_desired = True,
                               direction="Z",
                               speed = 0.004,
                               force_threshold = 10,
                               rotation_speed = 5,
                               max_angle = 360,
                               peck_mode = False,
                               max_rotation_torque=1):
  
    speed = speed / 1000 # TODO: change speed input units to meters instead of mm and remove this line
    max_force_control_position_deviation = 0.002 # TODO: add a parameter for this in the interface
  
    if (rq_insertion_force_node_id == -1):
        create_all_insertion_nodes()
    end
  
    # define the direction sign
    rq_actual_to_destination = pose_trans(pose_inv(get_actual_tcp_pose()), rq_ins_destination)
    axis = str_at(direction, 0)
    direction_sign = 1
    direction = str_cat(axis,"+")
    if axis == "X":
      rq_ins_offset = p[rq_actual_to_destination[0], 0, 0, 0, 0, 0]
      rot_axe = 3
      axis_index = 0
    elif axis == "Y":
      rq_ins_offset = p[0, rq_actual_to_destination[1], 0, 0, 0, 0]
      rot_axe = 4
      axis_index = 1
    elif axis == "Z":
      rq_ins_offset = p[0, 0, rq_actual_to_destination[2], 0, 0, 0]
      rot_axe = 5
      axis_index = 2
    else:
      textmsg("insertion: invalid direction ", direction)
    end
    if (rq_actual_to_destination[axis_index] < 0):
      direction_sign = -1
      direction = str_cat(axis,"-")
      positive_rotation_desired = not positive_rotation_desired
    end
  
    distance_to_destination = norm( rq_actual_to_destination[axis_index] )
  
    contact_with_piece_initiated = rq_linear_search_urcap(direction, force_threshold, speed, distance_to_destination, feature = 1)
  
    if( contact_with_piece_initiated ):
  
      # verify validity of user inputs
      if ((rotation_speed <= 0) or (rotation_speed > 60)):
        popup("rotation speed parameter in degrees / second must be between 0.01 and 60","ERROR rq_insert_rotation_urcap")
        halt
      elif ((max_rotation_torque < 0.01) or (max_rotation_torque > 15)):
        popup("max_rotation_torque parameter in Newton-meter must be between 0.01 and 15","ERROR rq_insert_rotation_urcap")
        halt
      elif ((max_angle <= 1) or (max_angle > 360)):
        popup("max_angle parameter in degree must be between 1 and 360","ERROR rq_insert_rotation_urcap")
        halt
      end
  
      # initialize forcenode: adapt to direction
      node_execution_thread = initialise_force_node(position_controlled_direction = axis_index,
                                                    feature = 1,
                                                    max_position_deviation = max_force_control_position_deviation)
  
      if positive_rotation_desired:
        rot_direction_sign = 1
      else:
        rot_direction_sign = -1
      end
      rq_ins_speed_setting = speed
      posrot = p[0,0,0,0,0,0]
      maxRotation = d2r(max_angle)
      rot_step = d2r(rotation_speed) * rq_controller_time_step * rot_direction_sign * direction_sign
      line_step = rq_ins_speed_setting * rq_controller_time_step * direction_sign
      rot_actual_angle = 0
      rot_actual_mode = 1 #1= linear, 2 = rotation
      rot_actual_distance = 0
      ins_rotation_initial_pose = get_actual_tcp_pose()
      rq_actual_to_destination = pose_trans( pose_inv(ins_rotation_initial_pose), rq_ins_destination )
      distance_to_destination = norm( rq_actual_to_destination[axis_index] )
  
      if peck_mode:
        #peck mode
        positive_rotation_computed = positive_rotation_desired
        while ( (norm(rot_actual_distance) < distance_to_destination) and (norm(rot_actual_angle) <= maxRotation) ):
          is_max_torque_reached = norm(get_applied_tcp_force(rot_axe)) > max_rotation_torque
          if (ins_actual_force_urcap(direction) >= force_threshold):
            #goes up
            posrot[axis_index] = rot_actual_distance - 0.002 * direction_sign
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            node_rpc_server.movejdefinewaypoint(rq_insertion_movej_node_id, next_joint_pos, 0.4, 0.4)
            execute_node(rq_insertion_movej_node_id, False )
            #rotate
            rot_actual_angle = compute_rotation_next_angle(rot_actual_angle, 285 * rot_step, is_max_torque_reached) # value of 285 define the peck mode "step size". determined ad oc
            posrot[rot_axe] = rot_actual_angle
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            node_rpc_server.movejdefinewaypoint(rq_insertion_movej_node_id, next_joint_pos, 1, 1)
            execute_node(rq_insertion_movej_node_id, False )
            #go back in touch with the part
            posrot[axis_index] = rot_actual_distance
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            node_rpc_server.movejdefinewaypoint(rq_insertion_movej_node_id, next_joint_pos, 0.4, 0.3)
            execute_node(rq_insertion_movej_node_id, False )
            sleep(0.1)
          else:
            rot_actual_distance = rot_actual_distance + line_step
            posrot[axis_index] = rot_actual_distance
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            update_servoj_node_target(next_joint_pos)
            if (rq_active_node != rq_insertion_servoj_node_id):
              active_and_reset_node(rq_insertion_servoj_node_id)
            end
          end # if
        end # while
      else:
        #normal mode
        while ( (norm(rot_actual_distance) <= distance_to_destination) and (norm(rot_actual_angle) <= maxRotation) ):
          is_max_torque_reached = norm(get_applied_tcp_force(rot_axe)) > max_rotation_torque
          if ( norm(get_applied_tcp_force(axis_index)) >= force_threshold ):
            if (rot_actual_mode == 1):
              rot_actual_distance = rot_actual_distance - line_step
              posrot[axis_index] = rot_actual_distance
            end
            rot_actual_angle = compute_rotation_next_angle(rot_actual_angle, rot_step, is_max_torque_reached)
            posrot[rot_axe] = rot_actual_angle
            rot_actual_mode = 2
          else:
            rot_actual_distance = rot_actual_distance + line_step
            posrot[axis_index] = rot_actual_distance
            rot_actual_mode = 1
          end # if
          next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
          next_joint_pos = get_inverse_kin(next_tcp_pose)
          update_servoj_node_target(next_joint_pos)
        end # while
      end # if peck_mode
  
      kill_thread( node_execution_thread )
      stopj(2)
      rq_rotation_not_completed = (norm(rot_actual_angle) > maxRotation)
    else: # inital find_surface was unsuccessfull
      rq_rotation_not_completed = False
    end # if contact_with_piece_initiated
  
    return rq_rotation_not_completed
  end # insert rotation 2
  
  def compute_rotation_next_angle(current_angle, step, is_max_torque_reached):
  #This function compute the rotation angle for rotational insertion by
  # incrementing the current angle by the desired step size.
  # If the maximal torque is reached, the rotation goes backward to
  # return to a admissible torque. In the backward direction,
  # a smaller step size is used to prevent constant oscillation between to steps
    if (is_max_torque_reached):
        new_angle = current_angle - 0.8 * step
    else:
        new_angle = current_angle + step
    end
    return new_angle
  end
  
  def center_one_axis(axis, lin_search_stop_force_threshold, speed, max_distance, feature):
    # Initiate contact in forward direction
    contact_initiated = rq_linear_search_urcap( str_cat(axis, "+"), lin_search_stop_force_threshold, speed, max_distance, feature)
    if contact_initiated:
      forward_contact_pose = get_actual_tcp_pose()
      # Initiate contact in reverse direction
      contact_initiated = rq_linear_search_urcap(str_cat(axis, "-"), lin_search_stop_force_threshold, speed, max_distance, feature)
      if contact_initiated:
        reverse_contact_pose = get_actual_tcp_pose()
        # Go to average of contact points
        pose_center_1 = interpolate_pose(forward_contact_pose, reverse_contact_pose, 0.5)
        movel(pose_center_1, a=0.6, v=speed)
      end
    end
    return contact_initiated
  end
  
  def rq_insert_recenter_urcap(axis = "Z", max_distance = 0.1, speed = 0.005, feature = 1, lin_search_stop_force_threshold = 5):
  
    if (max_distance < 0) or (max_distance > 1):
      popup("max_distance parameter in m must be between 0 and 1","ERROR rq_insert_recenter_urcap")
      halt
    elif (speed < 0.0001) or (speed > 0.5):
      popup("max_radius parameter in mm must be between 0.0001m/s and 0.5m/s","ERROR rq_insert_recenter_urcap")
      halt
    end
  
    #--------------------------------------------------------------------------------------------------------------------
    #For insertion in the X axis
    #--------------------------------------------------------------------------------------------------------------------
    if (axis == "X"):
      recenter_axis_1 = "Y"
      recenter_axis_2 = "Z"
    #--------------------------------------------------------------------------------------------------------------------
    #For insertion in the Y axis
    #--------------------------------------------------------------------------------------------------------------------
    elif (axis == "Y"):
      recenter_axis_1 = "X"
      recenter_axis_2 = "Z"
    #--------------------------------------------------------------------------------------------------------------------
    #For insertion in the Z axis
    #--------------------------------------------------------------------------------------------------------------------
    elif (axis == "Z"):
      recenter_axis_1 = "X"
      recenter_axis_2 = "Y"
    end
  
    recenter_successfull = center_one_axis(recenter_axis_1, lin_search_stop_force_threshold, speed, max_distance, feature)
    if recenter_successfull:
      recenter_successfull = center_one_axis(recenter_axis_2, lin_search_stop_force_threshold, speed, max_distance, feature)
    end
  
    if (recenter_successfull == False):
      textmsg("rq_insert_recenter_urcap failed, could not initiate contact with piece")
    end
  
    return recenter_successfull
  end # rq_insert_recenter_urcap
  
  # ******************* MAIN of Insertion Preamble *******************
  storevar.clearall()
  global rq_insertion_force_node_id = -1
  #************************************************
  #Function:  rq_linear_search_urcap(direction="Z+", force[N] = 10, speed[m/s] = 0.004, max_distance[m] = 0.02)
  #   Find a specific force in the direction of "direction".
  #   Robot will move towards a max_distance from the current position in the tool frame
  #   Return True if the force is detected during the robot motion
  #
  #************************************************
  def rq_linear_search_urcap(direction="Z+", force_threshold = 10, speed = 0.004, max_distance = 0.02, feature = 0 ):
  
    if (max_distance > 2.0):
      popup("maximum distance parameter in meters must be between 0 and 2.0","ERROR rq_linear_search_urcap")
      halt
    elif (speed < 0.0001) or (speed > 0.15):
      popup("speed parameter in mm/s must be between 0.1 and 150","ERROR rq_linear_search_urcap")
      halt
    elif (force_threshold < 0.0) or (force_threshold > 200):
      popup("Force parameter in Newtons must be between 0 and 200","ERROR rq_linear_search_urcap")
      halt
    elif (feature != 0) and (feature != 1):
      popup("feature value should be 0 for base or 1 for tool","ERROR rq_linear_search_urcap")
      halt
    end
  
    feature_base = 0
    feature_tool = 1
    steptime = get_steptime()
    force_index = 0
  
    axis = str_at(direction, 0)
    sign = str_at(direction, 1)
  
    direction_sign = 1
    if sign == "-":
      direction_sign = -1
      max_distance = max_distance * direction_sign
    end
  
    pose_offset = p[0,0,0,0,0,0]
    if (axis == "X") or (axis == "x"):
      pose_offset = p[max_distance,0,0,0,0,0]
      force_index = 0
    elif (axis == "Y") or (axis == "y"):
      pose_offset = p[0,max_distance,0,0,0,0]
      force_index = 1
    elif (axis == "Z") or (axis == "z"):
      pose_offset = p[0,0,max_distance,0,0,0]
      force_index = 2
    else:
      popup("direction parameter must be X+, X-, Y+, Y-, Z+ or Z-","ERROR rq_linear_search_urcap")
      halt
    end
  
    pose_from = get_actual_tcp_pose()
    pose_to = pose_from
    if feature == feature_base:
      pose_to = pose_add(pose_from, pose_offset)
    elif feature == feature_tool:
      pose_to = pose_trans(pose_from, pose_offset)
    end
  
    distance = point_dist(pose_from, pose_to)
    number_pose_interpolate = floor(distance / (speed * steptime)) + 1
    delta_alpha = 1.0 / number_pose_interpolate
  
    alpha = 0.0
    local surface_found = False
  
    while (alpha <= 1.0) and (not surface_found):
      alpha = alpha + delta_alpha
      pose_interpolate = interpolate_pose(pose_from, pose_to, alpha)
      servoj(get_inverse_kin(pose_interpolate), 0.1, 0.1, steptime, 0.05, 500)
  
      force = 0
      if feature == feature_base:
        force = get_applied_base_force(force_index)
      elif feature == feature_tool:
        force = get_applied_tcp_force(force_index)
      end
  
      if (direction_sign * force) >= force_threshold:
        surface_found = True
      end
    end
  
    return surface_found
  
  end
  
    ##############################################
    # OFFSET FEATURE-RELATED VARIABLES AND METHODS
    ##############################################
    rq_hasOffsetReference = False
    rq_isContactOffsetFeatureCached = False
    rq_featureCache = p[0, 0, 0, 0, 0, 0]
    rq_isContactOffsetInUse = False
  
    def cross_product(vector1,vector2):
      v_temp=[0,0,0]
      v_temp[0]=vector1[1]*vector2[2]-vector1[2]*vector2[1]
      v_temp[1]=vector1[2]*vector2[0]-vector1[0]*vector2[2]
      v_temp[2]=vector1[0]*vector2[1]-vector1[1]*vector2[0]
      return v_temp
    end
  
    def relocate_xyzr(init_feature, init_touch_pose, touch_pose):
      init_touch_pose_2_init_feature = pose_trans( pose_inv(init_touch_pose), init_feature)
      new_feature = pose_trans( touch_pose, init_touch_pose_2_init_feature )
  
      return new_feature
    end
  
    def relocate_orientation(touch1_init_pose, touch2_init_pose, feature_init_pose, touch1_pose, touch2_pose):
      #when relocating using 2 touch, the center of rotation is around touch point 1 (this could be changed)
  
      # initial touch2 pose in initial touch 1 pose frame:
      touch2_initial_pose_in_touch1_initial_pose_frame = pose_trans(pose_inv(touch1_init_pose), touch2_init_pose)
  
      # find theoric touch2_pose if no rotation
      touch2_pose_if_no_rotation = pose_trans(touch1_pose, touch2_initial_pose_in_touch1_initial_pose_frame)
  
      # vectors touch1 to touch2
      touch1_pose_to_touch2_pose = pose_trans(pose_inv(touch1_pose), touch2_pose)
      touch1_pose_to_touch2_pose_if_no_rotation = pose_trans(pose_inv(touch1_pose), touch2_pose_if_no_rotation)
  
      #angle axis calculation
      normal_vector = cross_product(touch1_pose_to_touch2_pose_if_no_rotation, touch1_pose_to_touch2_pose)
      normal_vector_norm = norm(normal_vector)
      if (normal_vector_norm > 10e-6):
        rotation_angle_rad = asin( normal_vector_norm / (norm(touch1_pose_to_touch2_pose_if_no_rotation) * norm(touch1_pose_to_touch2_pose) ) )
        normal_vector_to_angle_axis_multiply_norm_factor = rotation_angle_rad / normal_vector_norm
        angle_axis = [normal_vector[0] * normal_vector_to_angle_axis_multiply_norm_factor, normal_vector[1] * normal_vector_to_angle_axis_multiply_norm_factor, normal_vector[2] * normal_vector_to_angle_axis_multiply_norm_factor]
        rotation_offset_pose = p[0, 0, 0, angle_axis[0], angle_axis[1], angle_axis[2]]
  
        #rotate touch1 pose using touch2 information
        touch1_pose_rotated = pose_trans(touch1_pose, rotation_offset_pose)
      else:
        touch1_pose_rotated = touch1_pose
      end
  
      # relocate the feature using touch1_rotated_pose
      return relocate_xyzr(feature_init_pose, touch1_init_pose, touch1_pose_rotated)
    end
  
    def relocate_1_touch(touch_init_pose, touch_pose, feature_init_pose, feature_actual_pose):
      touch_initial_pose_in_initial_feature_frame = pose_trans(pose_inv(feature_init_pose), touch_init_pose)
      touch_actual_pose_in_actual_feature_frame = pose_trans(pose_inv(feature_actual_pose), touch_pose)
  
      # difference between touch poses in their respective feature frame
      touch_pose_offset = pose_sub(touch_actual_pose_in_actual_feature_frame, touch_initial_pose_in_initial_feature_frame)
  
      # remove all rotation from offset
      touch_pose_offset[3] = 0
      touch_pose_offset[4] = 0
      touch_pose_offset[5] = 0
  
      # apply pose offset to actual feature
      return pose_trans(feature_actual_pose, touch_pose_offset)
    end
    global servojId = 2
  rq_collision_detection_stop()
  contactOffsetXmlRpcClient = rpc_factory("xmlrpc","http://localhost:40417")
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Grippers, 1.7.2.3, Robotiq Inc.
  #   Type: Gripper
  #aliases for the gripper variable names
  ACT = 1
  GTO = 2
  ATR = 3
  ARD = 4
  FOR = 5
  SPE = 6
  OBJ = 7
  STA = 8
  FLT = 9
  POS = 10
  PRE = 11
  LBP = 12
  LRD = 13
  LBL = 14
  LGN = 15
  MSC = 16
  MOD = 17
  
  gripper_1_connected = False
  gripper_2_connected = False
  gripper_3_connected = False
  gripper_4_connected = False
  
  gripper_1_socket_open = False
  gripper_2_socket_open = False
  gripper_3_socket_open = False
  gripper_4_socket_open = False
  
  gripper_socket_acquire_option = False
  gripper_1_socket_acquired = False
  gripper_2_socket_acquired = False
  gripper_3_socket_acquired = False
  gripper_4_socket_acquired = False
  
  def rq_init_comm_if_connected(gripper_sid=9, gripper_socket="1"):
      if(not is_gripper_socket_open(gripper_socket)):
        open_gripper_socket(gripper_socket)
      end
  
      is_gripper_connected = rq_is_gripper_connected(gripper_sid, gripper_socket)
      if(is_gripper_connected):
          rq_set_gripper_connected(gripper_socket)
      end
  
      return is_gripper_connected
  end
  
  def open_gripper_socket(gripper_socket):
    is_open = socket_open("127.0.0.1",63352, gripper_socket)
    set_gripper_socket_open(gripper_socket, is_open)
  end
  
  def is_gripper_socket_open(gripper_socket):
    if(gripper_socket == "1"):
      return gripper_1_socket_open
    elif(gripper_socket == "2"):
      return gripper_2_socket_open
    elif(gripper_socket == "3"):
      return gripper_3_socket_open
    elif(gripper_socket == "4"):
      return gripper_4_socket_open
    else:
      return False
    end
  end
  
  def set_gripper_socket_open(gripper_socket, is_open):
    if(gripper_socket == "1"):
      gripper_1_socket_open = is_open
    elif(gripper_socket == "2"):
      gripper_2_socket_open = is_open
    elif(gripper_socket == "3"):
      gripper_3_socket_open = is_open
    elif(gripper_socket == "4"):
      gripper_4_socket_open = is_open
    else:
    end
  end
  
  def rq_is_gripper_connected(gripper_sid=9, gripper_socket="1"):
      socket_set_var("SID", gripper_sid,  gripper_socket)
      ack = socket_read_byte_list(3, gripper_socket, 0.1)
      return is_ack(ack)
  end
  
  def rq_set_gripper_connected(gripper_id="1"):
      if(gripper_id == "1"):
          gripper_1_connected = True
      end
  
      if (gripper_id == "2"):
          gripper_2_connected = True
      end
  
      if (gripper_id == "3"):
          gripper_3_connected = True
      end
  
      if (gripper_id == "4"):
          gripper_4_connected = True
      end
  end
  
  def rq_wait_for_gripper_connected():
      gripper_socket = "gripper_conn_socket"
      socket_open("127.0.0.1",63352, gripper_socket)
  
      retryCtr = 1
      sid_list = rq_get_sid(gripper_socket)
      gripper_is_connected = rq_is_any_gripper_connected(sid_list)
  
      while(not gripper_is_connected and retryCtr < 2000):
          retryCtr = retryCtr + 1
          sid_list = rq_get_sid(gripper_socket)
          gripper_is_connected = rq_is_any_gripper_connected(sid_list)
      end
  
      socket_close(gripper_socket)
  end
  
  def rq_is_any_gripper_connected(sid_list):
      is_gripper_1_connected = rq_is_gripper1_in_sid_list(sid_list)
      is_gripper_2_connected = rq_is_gripper2_in_sid_list(sid_list)
      is_gripper_3_connected = rq_is_gripper3_in_sid_list(sid_list)
      is_gripper_4_connected = rq_is_gripper4_in_sid_list(sid_list)
  
      if(is_gripper_1_connected or is_gripper_2_connected or is_gripper_3_connected or is_gripper_4_connected):
          return True
      else:
          return False
      end
  end
  
  def rq_is_gripper_in_sid_list(gripper_sid, sid_list):
      sid_list_length = sid_list[0]
      sid_list_empty_length = 2
  
      if (sid_list_length <= sid_list_empty_length):
          return False
      end
  
      sid1 = sid_list[2]
      sid2 = sid_list[5]
      sid3 = sid_list[8]
      sid4 = sid_list[11]
  
      if(sid1 == gripper_sid or sid2 == gripper_sid or sid3 == gripper_sid or sid4 == gripper_sid):
          return True
      else:
          return False
      end
  end
  
  def rq_is_gripper1_in_sid_list(sid_list):
      gripper_1_sid_ascii = 57
      return rq_is_gripper_in_sid_list(gripper_1_sid_ascii, sid_list)
  end
  
  def rq_is_gripper2_in_sid_list(sid_list):
      gripper_2_sid_ascii = 50
      return rq_is_gripper_in_sid_list(gripper_2_sid_ascii, sid_list)
  end
  
  def rq_is_gripper3_in_sid_list(sid_list):
      gripper_3_sid_ascii = 51
      return rq_is_gripper_in_sid_list(gripper_3_sid_ascii, sid_list)
  end
  
  def rq_is_gripper4_in_sid_list(sid_list):
      gripper_4_sid_ascii = 52
      return rq_is_gripper_in_sid_list(gripper_4_sid_ascii, sid_list)
  end
  
  def rq_set_sid(gripper_sid=9, gripper_socket="1"):
      socket_set_var("SID", gripper_sid,  gripper_socket)
      sync()
      ack = socket_read_byte_list(3, gripper_socket)
      return is_ack(ack)
  end
  
  def rq_get_sid(gripper_socket="1"):
      socket_send_string("GET SID", gripper_socket)
      sync()
      sid_list = socket_read_byte_list(17, gripper_socket)
      sync()
      return sid_list
  end
  
  def rq_activate(gripper_socket="1"):
      rq_gripper_act = 0
  
      if (not rq_is_gripper_activated(gripper_socket)):
         rq_reset(gripper_socket)
  
         while(socket_get_var("ACT",gripper_socket) == 1):
            sleep(0.1)
            rq_reset(gripper_socket)
         end
  
         rq_set_var(ACT,1, gripper_socket)
      end
  end
  
  def rq_activate_and_wait(gripper_socket="1"):
      rq_activate(gripper_socket)
      sleep(1.0)
  
      while(not rq_is_gripper_activated(gripper_socket)):
          # wait for activation completed
      end
      sleep(0.5)
  end
  
  def rq_activate_all_grippers(reset=False):
      if(gripper_1_connected):
          rq_reset_and_activate("1", reset)
      end
  
      if(gripper_2_connected):
          rq_reset_and_activate("2", reset)
      end
  
      if(gripper_3_connected):
          rq_reset_and_activate("3", reset)
      end
  
      if(gripper_4_connected):
          rq_reset_and_activate("4", reset)
      end
  
      sleep(0.2)
  end
  
  def rq_reset_and_activate(gripper_socket="1", reset=False):
      if(reset):
          rq_reset(gripper_socket)
          sleep(0.5)
          rq_activate_and_wait(gripper_socket)
      elif(not rq_is_gripper_activated(gripper_socket)):
          rq_activate_and_wait(gripper_socket)
      end
  end
  
  def rq_scan_block():
      gripper_socket = "scn_block_socket"
      socket_open("127.0.0.1", 63352, gripper_socket)
      socket_set_var("SCN_BLOCK", 1, gripper_socket)
      sync()
      ack_test = socket_read_byte_list(3, gripper_socket)
  
      retry_counter = 0
  
      while(not is_ack(ack_test) and retry_counter < 5):
          socket_set_var("SCN_BLOCK", 1, gripper_socket)
          sync()
          ack_test = socket_read_byte_list(3, gripper_socket)
          retry_counter = retry_counter + 1
      end
  
      socket_close("scn_block_socket")
  end
  
  def rq_reset(gripper_socket="1"):
      rq_gripper_act = 0
      rq_obj_detect = 0
      rq_mov_complete = 0
  
      rq_set_var(ACT,0, gripper_socket)
      rq_set_var(ATR,0, gripper_socket)
  
      sleep(0.2)
  end
  
  def rq_auto_release_open_and_wait(gripper_socket="1"):
      rq_set_var(ARD,0, gripper_socket)
      rq_set_var(ACT,1, gripper_socket)
      rq_set_var(ATR,0, gripper_socket)
      sleep(0.1)
      rq_set_var(ATR,1, gripper_socket)
  
      rq_wait_autorelease_completed(gripper_socket)
  end
  
  def rq_auto_release_close_and_wait(gripper_socket="1"):
      rq_set_var(ARD,1, gripper_socket)
      rq_set_var(ACT,1, gripper_socket)
      rq_set_var(ATR,0, gripper_socket)
      sleep(0.1)
      rq_set_var(ATR,1, gripper_socket)
  
      rq_wait_autorelease_completed(gripper_socket)
  end
  
  def rq_wait_autorelease_completed(gripper_socket="1"):
      retryCounter = 1
      gFLT = rq_get_var(FLT, 2, gripper_socket)
  
      while(not is_FLT_autorelease_in_progress(gFLT) and retryCounter <= 20):
          retryCounter = retryCounter + 1
          gFLT = rq_get_var(FLT, 2, gripper_socket)
          sleep(0.1)
      end
  
      retryCounter = 1
      gFLT = rq_get_var(FLT, 2, gripper_socket)
  
      while(not is_FLT_autorelease_completed(gFLT) and retryCounter <= 100):
          retryCounter = retryCounter + 1
          gFLT = rq_get_var(FLT, 2, gripper_socket)
          sleep(0.1)
      end
  end
  
  def rq_set_force(force, gripper_socket="1"):
      force = floor(scale(force, [0, 255], [0.0, 255.0]))
      rq_set_var(FOR, force, gripper_socket)
  end
  
  def rq_set_speed(speed, gripper_socket="1"):
      speed = floor(scale(speed, [0, 255], [0.0, 255.0]))
      rq_set_var(SPE, speed, gripper_socket)
  end
  
  def rq_open(gripper_socket="1"):
      rq_move(0, gripper_socket)
  end
  
  def rq_close(gripper_socket="1"):
      rq_move(255, gripper_socket)
  end
  
  def rq_open_and_wait(gripper_socket="1"):
      rq_move_and_wait(0, gripper_socket)
  end
  
  def rq_close_and_wait(gripper_socket="1"):
      rq_move_and_wait(255, gripper_socket)
  end
  
  def rq_move(pos, gripper_socket="1"):
      rq_mov_complete = 0
      rq_obj_detect = 0
  
      rq_set_pos(pos, gripper_socket)
      rq_go_to(gripper_socket)
  end
  
  def rq_move_and_wait(pos, gripper_socket="1"):
      rq_move(pos, gripper_socket)
  
      while (not rq_is_motion_complete(gripper_socket)):
          # wait for motion completed
          sleep(0.01)
          sync()
      end
  
      # following code used for compatibility with previous versions
      rq_is_object_detected(gripper_socket)
  
      if (rq_obj_detect != 1):
          rq_mov_complete = 1
      end
  end
  
  def rq_wait_for_pos_request(pos, gripper_socket="1"):
      gPRE = rq_get_var(PRE, 3, gripper_socket)
      pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
  
      while (pre != pos):
          rq_set_var(POS, pos, gripper_socket)
          gPRE = rq_get_var(PRE, 3, gripper_socket)
          pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
          sync()
          # The following patch is for Robotiq's Camera issue when communication is lost, but not the activation
          # the communication driver reset the GTO bit
          rq_go_to(gripper_socket)
      end
  end
  
  def rq_wait_for_pos(pos, gripper_socket="1"):
      rq_wait_for_pos_request(pos, gripper_socket)
  
      # Wait for the gripper motion to complete
      while (not rq_is_motion_complete(gripper_socket)):
          # wait for motion completed
          sleep(0.01)
          sync()
          rq_go_to(gripper_socket)
      end
  
      # following code used for compatibility with previous versions
      rq_is_object_detected(gripper_socket)
  
      if (rq_obj_detect != 1):
          rq_mov_complete = 1
      end
  end
  
  def rq_wait(gripper_socket="1"):
      # Wait for the gripper motion to complete
      while (not rq_is_motion_complete(gripper_socket)):
          # wait for motion completed
          sleep(0.01)
          sync()
      end
  
      # following code used for compatibility with previous versions
      rq_is_object_detected(gripper_socket)
  
      if (rq_obj_detect != 1):
          rq_mov_complete = 1
      end
  end
  
  def rq_wait_for_object_detected(gripper_socket="1"):
      # Wait the object detection
      while (not rq_is_object_detected(gripper_socket)):
          # wait for motion completed
          sleep(0.01)
          sync()
      end
  end
  
  # set the position
  def rq_set_pos(pos, gripper_socket="1"):
      pos = floor(scale(pos, [0, 255], [0.0, 255.0]))
      rq_set_var(POS, pos, gripper_socket)
      rq_wait_for_pos_request(pos, gripper_socket)
  end
  
  # set the position, speed and force
  def rq_set_pos_spd_for(pos, speed, force, gripper_socket="1"):
      rq_acquire_gripper_socket(gripper_socket)
      rq_send_pos_spd_for(pos, speed, force, gripper_socket)
      ack = socket_read_byte_list(3, gripper_socket)
      rq_release_gripper_socket(gripper_socket)
  
      sync()
  
      while(is_not_ack(ack)):
          rq_acquire_gripper_socket(gripper_socket)
          rq_send_pos_spd_for(pos, speed, force, gripper_socket)
          ack = socket_read_byte_list(3, gripper_socket)
          rq_release_gripper_socket(gripper_socket)
  
          sync()
      end
  
      rq_wait_for_pos_request(pos, gripper_socket)
  end
  
  def rq_set_gripper_max_current_mA(current_mA, gripper_socket="1"):
      current = floor(current_mA / 10)
      rq_set_var(MSC, current, gripper_socket)
      sleep(1.5)
  end
  
  def rq_set_gripper_mode(mode, gripper_socket="1"):
      rq_set_var(MOD, mode, gripper_socket)
  end
  
  def rq_set_gripper_max_cur(current_mA, gripper_socket="1"):
      rq_set_gripper_max_current_mA(current_mA, gripper_socket)
  end
  
  def rq_set_max_current_for_all_grippers():
      current_mA = rq_get_max_current_mA()
  
      if(gripper_1_connected):
          rq_set_gripper_max_current_mA(current_mA, "1")
      end
  
      if(gripper_2_connected):
          rq_set_gripper_max_current_mA(current_mA, "2")
      end
  
      if(gripper_3_connected):
          rq_set_gripper_max_current_mA(current_mA, "3")
      end
  
      if(gripper_4_connected):
          rq_set_gripper_max_current_mA(current_mA, "4")
      end
  
      sleep(0.2)
  end
  
  def rq_get_max_current_mA():
      max_current_mA = 0
  
      if(rq_current_limit_enabled):
          nb_connected_grippers = rq_get_nb_connected_grippers()
  
          if(nb_connected_grippers == 1):
              max_current_mA = 600
          elif(nb_connected_grippers > 1):
              max_current_mA = 450
          end
      else:
  
      end
  
      return max_current_mA
  end
  
  def rq_get_nb_connected_grippers():
      nb_connected_grippers = 0
  
      if(gripper_1_connected):
          nb_connected_grippers = nb_connected_grippers + 1
      end
  
      if(gripper_2_connected):
          nb_connected_grippers = nb_connected_grippers + 1
      end
  
      if(gripper_3_connected):
          nb_connected_grippers = nb_connected_grippers + 1
      end
  
      if(gripper_4_connected):
          nb_connected_grippers = nb_connected_grippers + 1
      end
  
      return nb_connected_grippers
  end
  
  def rq_get_gripper_max_current_mA(gripper_socket="1"):
      socket_send_string("GET MSC",gripper_socket)
      sync()
      var_value = socket_read_byte_list(3, gripper_socket)
  
      current = rq_list_of_bytes_to_value(var_value)
  
      if(current == -1):
          current_mA = current
      else:
          current_mA = current * 10
      end
  
      return current_mA
  end
  
  def rq_get_gripper_max_cur(gripper_socket="1"):
      return rq_get_gripper_max_current_mA(gripper_socket)
  end
  
  def rq_list_of_bytes_to_value(list_of_bytes):
      value = -1
  
      # response list length
      if (list_of_bytes[0] == 1):
          value = list_of_bytes[1] - 48
      elif (list_of_bytes[0] == 2):
          value = (list_of_bytes[1] - 48) * 10 + (list_of_bytes[2] - 48)
      elif (list_of_bytes[0] == 3):
          value = (list_of_bytes[1] - 48) * 100 + (list_of_bytes[2] - 48) * 10 + (list_of_bytes[3] - 48)
      end
  
      return value
  end
  
  # send the position, speed and force
  def rq_send_pos_spd_for(pos, speed, force, gripper_socket="1"):
      pos = floor(scale(pos, [0, 255], [0.0, 255.0]))
      speed = floor(scale(speed, [0, 255], [0.0, 255.0]))
      force = floor(scale(force, [0, 255], [0.0, 255.0]))
  
      socket_send_string("SET POS", gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string(pos, gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string("SPE", gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string(speed, gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string("FOR", gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string(force, gripper_socket)
      socket_send_byte(10, gripper_socket)
  
      sync()
  end
  
  def rq_is_motion_complete(gripper_socket="1"):
      rq_mov_complete = 0
  
      gOBJ = rq_get_var(OBJ, 1, gripper_socket)
      sleep(0.01)
  
      if (is_OBJ_gripper_at_position(gOBJ)):
          rq_mov_complete = 1
          return True
      end
  
      if (is_OBJ_object_detected(gOBJ)):
          rq_mov_complete = 1
          return True
      end
  
      return False
  
  end
  
  def rq_is_gripper_activated(gripper_socket="1"):
      gSTA = rq_get_var(STA, 1, gripper_socket)
  
      if(is_STA_gripper_activated(gSTA)):
          rq_gripper_act = 1
          return True
      else:
          rq_gripper_act = 0
          return False
      end
  end
  
  def rq_is_object_detected(gripper_socket="1"):
      gOBJ = rq_get_var(OBJ, 1, gripper_socket)
  
      if(is_OBJ_object_detected(gOBJ)):
          rq_obj_detect = 1
          return True
      else:
          rq_obj_detect = 0
          return False
      end
  end
  
  def rq_current_pos(gripper_socket="1"):
      rq_acquire_gripper_socket(gripper_socket)
      rq_pos = socket_get_var("POS",gripper_socket)
      rq_release_gripper_socket(gripper_socket)
      sync()
      return rq_pos
  end
  
  def rq_motor_current(gripper_socket="1"):
      rq_acquire_gripper_socket(gripper_socket)
      rq_current = socket_get_var("COU",gripper_socket)
      rq_release_gripper_socket(gripper_socket)
      sync()
      return rq_current * 10
  end
  
  def rq_print_connected_grippers():
      if(gripper_1_connected):
          textmsg("Gripper 1 : ", "connected and socket open.")
      end
  
      if (gripper_2_connected):
          textmsg("Gripper 2 : ", "connected and socket open.")
      end
  
      if (gripper_3_connected):
          textmsg("Gripper 3 : ", "connected and socket open.")
      end
  
      if (gripper_4_connected):
          textmsg("Gripper 4 : ", "connected and socket open.")
      end
  end
  
  def rq_print_gripper_fault_code(gripper_socket="1"):
      gFLT = rq_get_var(FLT, 2, gripper_socket)
  
      if(is_FLT_no_fault(gFLT)):
          textmsg("Gripper Fault : ", "No Fault (0x00)")
      elif (is_FLT_action_delayed(gFLT)):
          textmsg("Gripper Fault : ", "Priority Fault: Action delayed, initialization must be completed prior to action (0x05)")
      elif (is_FLT_not_activated(gFLT)):
          textmsg("Gripper Fault : ", "Priority Fault: The activation must be set prior to action (0x07)")
      elif (is_FLT_autorelease_in_progress(gFLT)):
          textmsg("Gripper Fault : ", "Minor Fault: Automatic release in progress (0x0B)")
      elif (is_FLT_overcurrent(gFLT)):
          textmsg("Gripper Fault : ", "Minor Fault: Overcurrent protection triggered (0x0E)")
      elif (is_FLT_autorelease_completed(gFLT)):
          textmsg("Gripper Fault : ", "Major Fault: Automatic release completed (0x0F)")
      else:
          textmsg("Gripper Fault : ", "Unknown Fault")
      end
  end
  
  def rq_print_gripper_num_cycles(gripper_socket="1"):
      socket_send_string("GET NCY",gripper_socket)
      sync()
      string_from_server = socket_read_string(gripper_socket)
      sync()
  
      if(string_from_server == "0"):
          textmsg("Gripper Cycle Number : ", "Number of cycles is unreachable.")
      else:
          textmsg("Gripper Cycle Number : ", string_from_server)
      end
  end
  
  def rq_print_gripper_driver_state(gripper_socket="1"):
      socket_send_string("GET DST",gripper_socket)
      sync()
      string_from_server = socket_read_string(gripper_socket)
      sync()
  
      if(string_from_server == "0"):
          textmsg("Gripper Driver State : ", "RQ_STATE_INIT")
      elif(string_from_server == "1"):
          textmsg("Gripper Driver State : ", "RQ_STATE_LISTEN")
      elif(string_from_server == "2"):
          textmsg("Gripper Driver State : ", "RQ_STATE_READ_INFO")
      elif(string_from_server == "3"):
          textmsg("Gripper Driver State : ", "RQ_STATE_ACTIVATION")
      else:
          textmsg("Gripper Driver State : ", "RQ_STATE_RUN")
      end
  end
  
  def rq_print_gripper_serial_number(gripper_socket="1"):
      socket_send_string("GET SNU",gripper_socket)
      sync()
      string_from_server = socket_read_string(gripper_socket)
      sync()
      textmsg("Gripper Serial Number : ", string_from_server)
  end
  
  def rq_print_gripper_firmware_version(gripper_socket="1"):
      socket_send_string("GET FWV",gripper_socket)
      sync()
      string_from_server = socket_read_string(gripper_socket)
      sync()
      textmsg("Gripper Firmware Version : ", string_from_server)
  end
  
  def rq_print_gripper_driver_version(gripper_socket="1"):
      socket_send_string("GET VER",gripper_socket)
      sync()
      string_from_server = socket_read_string(gripper_socket)
      sync()
      textmsg("Gripper Driver Version : ", string_from_server)
  end
  
  def rq_print_gripper_probleme_connection(gripper_socket="1"):
      socket_send_string("GET PCO",gripper_socket)
      sync()
      string_from_server = socket_read_string(gripper_socket)
      sync()
      if (string_from_server == "0"):
          textmsg("Gripper Connection State : ", "No connection problem detected")
      else:
          textmsg("Gripper Connection State : ", "Connection problem detected")
      end
  end
  
  # Returns True if list_of_bytes is [3, 'a', 'c', 'k']
  def is_ack(list_of_bytes):
  
      # list length is not 3
      if (list_of_bytes[0] != 3):
          return False
      end
  
      # first byte not is 'a'?
      if (list_of_bytes[1] != 97):
          return False
      end
  
      # first byte not is 'c'?
      if (list_of_bytes[2] != 99):
          return False
      end
  
      # first byte not is 'k'?
      if (list_of_bytes[3] != 107):
          return False
      end
  
      return True
  end
  
  # Returns True if list_of_bytes is not [3, 'a', 'c', 'k']
  def is_not_ack(list_of_bytes):
      if (is_ack(list_of_bytes)):
          return False
      else:
          return True
      end
  end
  
  def is_STA_gripper_activated (list_of_bytes):
  
      # list length is not 1
      if (list_of_bytes[0] != 1):
          return False
      end
  
      # byte is '3'?
      if (list_of_bytes[1] == 51):
          return True
      end
  
      return False
  end
  
  # Returns True if list_of_byte is [1, '1'] or [1, '2']
  # Used to test OBJ = 0x1 or OBJ = 0x2
  def is_OBJ_object_detected (list_of_bytes):
  
      # list length is not 1
      if (list_of_bytes[0] != 1):
          return False
      end
  
      # byte is '2'?
      if (list_of_bytes[1] == 50):
          return True
      end
  
      # byte is '1'?
      if (list_of_bytes[1]  == 49):
          return True
      end
  
      return False
  
  end
  
  # Returns True if list_of_byte is [1, '3']
  # Used to test OBJ = 0x3
  def is_OBJ_gripper_at_position (list_of_bytes):
  
      # list length is not 1
      if (list_of_bytes[0] != 1):
          return False
      end
  
      # byte is '3'?
      if (list_of_bytes[1] == 51):
          return True
      end
  
      return False
  end
  
  def is_not_OBJ_gripper_at_position (list_of_bytes):
  
      if (is_OBJ_gripper_at_position(list_of_bytes)):
          return False
      else:
          return True
      end
  end
  
  #### GTO Section ####
  def rq_stop(gripper_socket="1"):
      rq_set_var(GTO, 0, gripper_socket)
  end
  
  def rq_set_GTO_and_wait(value, gripper_socket="1"):
      rq_set_var(GTO ,value, gripper_socket)
      while(not is_GTO(value, rq_get_var(GTO, 1, gripper_socket))):
        sync()
      end
  end
  
  def rq_go_to(gripper_socket="1"):
      rq_set_var(GTO, 1, gripper_socket)
  end
  
  
  def is_GTO(goto_value, list_of_bytes):
      zero_ascii = 48
      if (list_of_bytes[0] != 1):
          return False
      end
  
      if (list_of_bytes[1] == zero_ascii + goto_value):
          return True
      else:
          return False
      end
  end
  #### GTO Section ####
  
  def is_FLT_no_fault(list_of_bytes):
  
      # list length is not 2
      if (list_of_bytes[0] != 2):
          return False
      end
  
      # first byte is '0'?
      if (list_of_bytes[1] != 48):
          return False
      end
  
      # second byte is '0'?
      if (list_of_bytes[2] != 48):
          return False
      end
  
      return True
  
  end
  
  def is_FLT_action_delayed(list_of_bytes):
  
      # list length is not 2
      if (list_of_bytes[0] != 2):
          return False
      end
  
      # first byte is '0'?
      if (list_of_bytes[1] != 48):
          return False
      end
  
      # second byte is '5'?
      if (list_of_bytes[2] != 53):
          return False
      end
  
      return True
  end
  
  def is_FLT_not_activated(list_of_bytes):
  
      # list length is not 2
      if (list_of_bytes[0] != 2):
          return False
      end
  
      # first byte is '0'?
      if (list_of_bytes[1] != 48):
          return False
      end
  
      # second byte is '7'?
      if (list_of_bytes[2] != 55):
          return False
      end
  
      return True
  end
  
  def is_FLT_autorelease_in_progress(list_of_bytes):
  
      # list length is not 2
      if (list_of_bytes[0] != 2):
          return False
      end
  
      # first byte is '1'?
      if (list_of_bytes[1] != 49):
          return False
      end
  
      # second byte is '1'?
      if (list_of_bytes[2] != 49):
          return False
      end
  
      return True
  
  end
  
  def is_FLT_overcurrent(list_of_bytes):
  
      # list length is not 2
      if (list_of_bytes[0] != 2):
          return False
      end
  
      # first byte is '1'?
      if (list_of_bytes[1] != 49):
          return False
      end
  
      # second byte is '4'?
      if (list_of_bytes[2] != 52):
          return False
      end
  
      return True
  
  end
  
  def is_FLT_autorelease_completed(list_of_bytes):
  
      # list length is not 2
      if (list_of_bytes[0] != 2):
          return False
      end
  
      # first byte is '1'?
      if (list_of_bytes[1] != 49):
          return False
      end
  
      # second byte is '5'?
      if (list_of_bytes[2] != 53):
          return False
      end
  
      return True
  
  end
  
  def rq_set_var(var_name, var_value, gripper_socket="1"):
  
      var_name_string = ""
  
      if (var_name == ACT):
          var_name_string = "ACT"
      elif (var_name == GTO):
          var_name_string = "GTO"
      elif (var_name == ATR):
          var_name_string = "ATR"
      elif (var_name == ARD):
          var_name_string = "ARD"
      elif (var_name == FOR):
          var_name_string = "FOR"
      elif (var_name == SPE):
          var_name_string = "SPE"
      elif (var_name == POS):
          var_name_string = "POS"
      elif (var_name == LBP):
          var_name_string = "LBP"
      elif (var_name == LRD):
          var_name_string = "LRD"
      elif (var_name == LBL):
          var_name_string = "LBL"
      elif (var_name == LGN):
          var_name_string = "LGN"
      elif (var_name == MSC):
          var_name_string = "MSC"
      elif (var_name == MOD):
          var_name_string = "MOD"
      end
  
      rq_acquire_gripper_socket(gripper_socket)
      socket_set_var(var_name_string, var_value, gripper_socket)
      sync()
      ack = socket_read_byte_list(3, gripper_socket)
      rq_release_gripper_socket(gripper_socket)
  
      sync()
  
      while(is_not_ack(ack)):
          rq_acquire_gripper_socket(gripper_socket)
          socket_set_var(var_name_string , var_value, gripper_socket)
          sync()
          ack = socket_read_byte_list(3, gripper_socket)
          rq_release_gripper_socket(gripper_socket)
  
          sync()
      end
  end
  
  
  def rq_get_var(var_name, nbr_bytes, gripper_socket="1"):
      rq_acquire_gripper_socket(gripper_socket)
  
      if (var_name == FLT):
          socket_send_string("GET FLT", gripper_socket)
      elif (var_name == OBJ):
          socket_send_string("GET OBJ", gripper_socket)
      elif (var_name == STA):
          socket_send_string("GET STA", gripper_socket)
      elif (var_name == PRE):
          socket_send_string("GET PRE", gripper_socket)
      elif (var_name == GTO):
          socket_send_string("GET GTO", gripper_socket)
      else:
      end
  
      sync()
  
      var_value = socket_read_byte_list(nbr_bytes, gripper_socket)
  
      rq_release_gripper_socket(gripper_socket)
  
      sync()
  
      return var_value
  end
  
  def rq_is_object_validated(gripper_selected, gripper_socket="1"):
      if(gripper_selected):
          if(rq_is_object_detected(gripper_socket)):
              return True
          else:
              return False
          end
      else:
          return True
      end
  end
  
  ############################################
  # normalized functions (maps 0-100 to 0-255)
  ############################################
  def rq_set_force_norm(force_norm, gripper_socket="1"):
      force_gripper = norm_to_gripper(force_norm)
      rq_set_force(force_gripper, gripper_socket)
  end
  
  def rq_set_speed_norm(speed_norm, gripper_socket="1"):
      speed_gripper = norm_to_gripper(speed_norm)
      rq_set_speed(speed_gripper, gripper_socket)
  end
  
  def rq_move_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_move(pos_gripper, gripper_socket)
  end
  
  def rq_move_and_wait_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_move_and_wait(pos_gripper, gripper_socket)
  end
  
  def rq_set_pos_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_set_pos(pos_gripper, gripper_socket)
  end
  
  def rq_current_pos_norm(gripper_socket="1"):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_norm = gripper_to_norm(pos_gripper)
      return pos_norm
  end
  
  def gripper_to_norm(value_gripper):
      value_norm = (value_gripper / 255) * 100
      return floor(value_norm)
  end
  
  def norm_to_gripper(value_norm):
      value_gripper = (value_norm / 100) * 255
      return ceil(value_gripper)
  end
  
  def rq_get_position():
      return rq_current_pos_norm()
  end
  
  def rq_gripper_led_on(gripper_socket="1"):
      rq_set_var(LBP,0, gripper_socket)
  end
  
  def rq_gripper_led_off(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,0, gripper_socket)
      rq_set_var(LBL,0, gripper_socket)
      rq_set_var(LGN,0, gripper_socket)
  end
  
  def rq_gripper_led_force_red(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,1, gripper_socket)
      rq_set_var(LBL,0, gripper_socket)
      rq_set_var(LGN,0, gripper_socket)
  end
  
  def rq_gripper_led_force_blue(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,0, gripper_socket)
      rq_set_var(LBL,1, gripper_socket)
      rq_set_var(LGN,0, gripper_socket)
  end
  
  def rq_gripper_led_force_green(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,0, gripper_socket)
      rq_set_var(LBL,0, gripper_socket)
      rq_set_var(LGN,1, gripper_socket)
  end
  
  def rq_gripper_led_force_purple(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,1, gripper_socket)
      rq_set_var(LBL,1, gripper_socket)
      rq_set_var(LGN,0, gripper_socket)
  end
  
  ############################################
  # mm/inches functions
  ############################################
  gripper_closed_norm = [100, 100, 100, 100]
  gripper_open_norm = [0, 0, 0, 0]
  gripper_closed_mm = [0, 0, 0, 0]
  gripper_open_mm = [50, 50, 50, 50]
  
  def rq_current_pos_mm(gripper_socket=1):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_mm = gripper_to_mm(pos_gripper, gripper_socket)
      return round_value_2_dec(pos_mm)
  end
  
  def rq_current_pos_inches(gripper_socket=1):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_mm = gripper_to_mm(pos_gripper, gripper_socket)
      pos_in = pos_mm / 25.4
      return round_value_2_dec(pos_in)
  end
  
  def rq_move_mm(pos_mm, gripper_socket=1):
      pos_gripper = mm_to_gripper(pos_mm, gripper_socket)
      rq_move(pos_gripper, gripper_socket)
  end
  
  def rq_move_and_wait_mm(pos_mm, gripper_socket=1):
      pos_gripper = mm_to_gripper(pos_mm, gripper_socket)
      rq_move_and_wait(pos_gripper, gripper_socket)
  end
  
  def rq_move_inches(pos_in, gripper_socket=1):
      pos_mm = pos_in * 25.4
      rq_move_mm(pos_mm, gripper_socket)
  end
  
  def rq_move_and_wait_inches(pos_in, gripper_socket=1):
      pos_mm = pos_in * 25.4
      rq_move_and_wait_mm(pos_mm, gripper_socket)
  end
  
  def get_closed_norm(gripper_socket):
      return gripper_closed_norm[gripper_socket - 1]
  end
  
  def get_open_norm(gripper_socket):
      return gripper_open_norm[gripper_socket - 1]
  end
  
  def get_closed_mm(gripper_socket):
      return gripper_closed_mm[gripper_socket - 1]
  end
  
  def get_open_mm(gripper_socket):
      return gripper_open_mm[gripper_socket - 1]
  end
  
  def set_closed_norm(closed_norm, gripper_socket):
      gripper_closed_norm[gripper_socket - 1] = closed_norm
  end
  
  def set_open_norm(open_norm, gripper_socket):
      gripper_open_norm[gripper_socket - 1] = open_norm
  end
  
  def set_closed_mm(closed_mm, gripper_socket):
      gripper_closed_mm[gripper_socket - 1] = closed_mm
  end
  
  def set_open_mm(open_mm, gripper_socket):
      gripper_open_mm[gripper_socket - 1] = open_mm
  end
  
  def gripper_to_mm(value_gripper, gripper_socket):
      closed_norm = get_closed_norm(gripper_socket)
      open_norm = get_open_norm(gripper_socket)
      closed_mm = get_closed_mm(gripper_socket)
      open_mm = get_open_mm(gripper_socket)
  
      value_norm = (value_gripper / 255) * 100
  
      slope = (closed_mm - open_mm) / (closed_norm - open_norm)
      value_mm = slope * (value_norm - closed_norm) + closed_mm
  
      if (value_mm > open_mm):
          value_mm_limited = open_mm
      elif (value_mm < closed_mm):
          value_mm_limited = closed_mm
      else:
          value_mm_limited = value_mm
      end
  
      return value_mm_limited
  end
  
  def mm_to_gripper(value_mm, gripper_socket):
      closed_norm = get_closed_norm(gripper_socket)
      open_norm = get_open_norm(gripper_socket)
      closed_mm = get_closed_mm(gripper_socket)
      open_mm = get_open_mm(gripper_socket)
  
      slope = (closed_norm - open_norm) / (closed_mm - open_mm)
      value_norm = (value_mm - closed_mm) * slope + closed_norm
  
      value_gripper = value_norm * 255 / 100
  
      if (value_gripper > 255):
          value_gripper_limited = 255
      elif (value_gripper < 0):
          value_gripper_limited = 0
      else:
          value_gripper_limited = round_value(value_gripper)
      end
  
      return value_gripper_limited
  end
  
  def round_value(value):
      value_mod = value % 1
  
      if(value_mod < 0.5):
          return floor(value)
      else:
          return ceil(value)
      end
  end
  
  def round_value_2_dec(value):
      value_x_100 = value * 100
      value_x_100_rounded = round_value(value_x_100)
      return value_x_100_rounded / 100
  end
  
  def clear_socket_buffer(gripper_socket="1", read_timeout = 0.1):
    byte_in_buffer = socket_read_byte_list(1, gripper_socket, read_timeout)
  
    while(byte_in_buffer[0] >= 1):
        byte_in_buffer = socket_read_byte_list(1, gripper_socket, read_timeout)
    end
  end
  
  def rq_set_gripper_socket_acquire_option(enabled=False):
      gripper_socket_acquire_option = enabled
  
      if(not enabled):
          gripper_1_socket_acquired = False
          gripper_2_socket_acquired = False
          gripper_3_socket_acquired = False
          gripper_4_socket_acquired = False
      end
  end
  
  def rq_acquire_gripper_socket(gripper_socket="1"):
      if(gripper_socket_acquire_option):
          rq_wait_gripper_socket_released(gripper_socket)
          enter_critical
              rq_set_gripper_socket_acquired(gripper_socket, True)
          exit_critical
  
          clear_socket_buffer(gripper_socket, 0.002)
  
          sync()
      end
  end
  
  def rq_release_gripper_socket(gripper_socket="1"):
      if(gripper_socket_acquire_option):
          rq_set_gripper_socket_acquired(gripper_socket, False)
  
          sync()
      end
  end
  
  def rq_set_gripper_socket_acquired(gripper_socket="1", acquired=False):
      if(gripper_socket == "1"):
          gripper_1_socket_acquired = acquired
      elif(gripper_socket == "2"):
          gripper_2_socket_acquired = acquired
      elif(gripper_socket == "3"):
          gripper_3_socket_acquired = acquired
      elif(gripper_socket == "4"):
          gripper_4_socket_acquired = acquired
      end
  end
  
  def rq_get_gripper_socket_acquired(gripper_socket="1"):
      if(gripper_socket == "1"):
          return gripper_1_socket_acquired
      elif(gripper_socket == "2"):
          return gripper_2_socket_acquired
      elif(gripper_socket == "3"):
          return gripper_3_socket_acquired
      elif(gripper_socket == "4"):
          return gripper_4_socket_acquired
      end
  
      sync()
  end
  
  def rq_wait_gripper_socket_released(gripper_socket="1"):
      while(rq_get_gripper_socket_acquired(gripper_socket)):
          sync()
      end
  
      sync()
  end
  
  def rq_gripper_id_to_ascii(gripper_id):
      if(gripper_id == "1"):
          return 57
      elif(gripper_id == "2"):
          return 50
      elif(gripper_id == "3"):
          return 51
      elif(gripper_id == "4"):
          return 52
      end
  end
  
  def scale(value, rawRange, scaledRange):
      def computeSlope(inputRange, outputRange):
          outputRangeDelta = outputRange[1] - outputRange[0]
          inputRangeDelta = inputRange[1] - inputRange[0]
  
          if (inputRangeDelta == 0):
              return 0
          else:
              return outputRangeDelta / inputRangeDelta
          end
      end
  
      def computeIntercept(slope, inputRange, outputRange):
          return outputRange[0] - (slope * inputRange[0])
      end
  
      def clipScaledValue(outputScaledValue, outputRange):
          if (outputRange[0] < outputRange[1]):
              return clipWhenLowerLimitIsLessThanHigher(outputScaledValue, outputRange)
          else:
              return clipWhenLowerLimitIsGreaterThanHigherLimit(outputScaledValue, outputRange)
          end
      end
  
      def clipWhenLowerLimitIsGreaterThanHigherLimit(outputScaledValue, outputRange):
          if (outputScaledValue < outputRange[1]):
              return outputRange[1]
          elif (outputScaledValue > outputRange[0]):
              return outputRange[0]
          else:
              return outputScaledValue
          end
      end
  
      def clipWhenLowerLimitIsLessThanHigher(outputScaledValue, outputRange):
          if (outputScaledValue < outputRange[0]):
              return outputRange[0]
          elif (outputScaledValue > outputRange[1]):
              return outputRange[1]
          else:
              return outputScaledValue
          end
      end
  
      slope = computeSlope(rawRange, scaledRange)
      intercept = computeIntercept(slope, rawRange, scaledRange)
      scaledValue = slope * value + intercept
      return clipScaledValue(scaledValue, scaledRange)
  end
  
  def limit(value, range):
      return scale(value, range, range)
  end
  
  
  rq_obj_detect = 0
  rq_init_comm_if_connected(9, "1")
  rq_init_comm_if_connected(2, "2")
  rq_init_comm_if_connected(3, "3")
  rq_init_comm_if_connected(4, "4")
  rq_print_connected_grippers()
  connectivity_checked = [-1,-1,-1,-1]
  status_checked = [-1,-1,-1,-1]
  current_speed = [-1,-1,-1,-1]
  current_force = [-1,-1,-1,-1]
  set_closed_norm(100.0, 1)
  set_open_norm(0.0, 1)
  set_closed_mm(0.0, 1)
  set_open_mm(50.0, 1)
  set_closed_norm(100.0, 2)
  set_open_norm(0.0, 2)
  set_closed_mm(0.0, 2)
  set_open_mm(50.0, 2)
  set_closed_norm(100.0, 3)
  set_open_norm(0.0, 3)
  set_closed_mm(0.0, 3)
  set_open_mm(50.0, 3)
  set_closed_norm(100.0, 4)
  set_open_norm(0.0, 4)
  set_closed_mm(0.0, 4)
  set_open_mm(50.0, 4)
  rq_current_limit_enabled = False
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: PART LOCALIZATION WITH SICK PLOC2D, 2.3.0, SICK AG - Developed by Nimalendiran Kailasanathan
  #   Type: PLOC2D HELP
  global PLOC2D_CONNECTION = "NOT CONNECTED"
  global ANYFEEDER_CONNECTION = "NOT CONNECTED"
  global PLOC2D_STATUS = "Job(s) not located."
  global PLOC_LOCATED = False
  global PLOC_IS_WITHIN_REACH = False
  global PLOC2D_JOB_ID = 0
  global PLOC2D_LOCATE_TRIALS = 0
  global PLOC2D_URPose = p[0,0,0,0,0,0]
   def ploc2d_wrist(pose,jRefPose,activeTCP):
			jJoints=get_inverse_kin(pose,jRefPose,1e-10,1e-10,activeTCP)
			return jJoints
	end
   def ploc_wrist_pose(pose,jRefPose,activeTCP):
			jJoints=get_inverse_kin(pose,jRefPose,1e-10,1e-10,activeTCP)
			finalPose=get_forward_kin(jJoints,activeTCP)
			return finalPose
	end
		def PLOC2D_SendString(PLOC2D_string): #Function to send a string over the socket. INPUT: string to send 
			PLOC2D_sent=False 
			#textmsg("string",PLOC2D_string) 
			PLOC2D_sent=socket_send_string(PLOC2D_string, "Sick_Ploc_Socket") 
			sleep(0.01)  
			if not PLOC2D_sent: 
	  			popup("Failed to send string message","Message Transmission Failure",False,True,blocking=True)  
			end 
		end 
		def PLOC2D_SendStringToAnyfeeder(PLOC2D_AnyfeederString): #Function to send a string over the socket. INPUT: string to send 
			PLOC2D_AnyfeederSent=False 
			#textmsg("string",PLOC2D_AnyfeederString) 
			PLOC2D_AnyfeederSent=socket_send_string(PLOC2D_AnyfeederString, "Anyfeeder_Socket") 
			sleep(0.01)  
			if not PLOC2D_AnyfeederSent: 
	  			popup("Failed to send string message","Message Transmission Failure",False,True,blocking=True)  
			end 
		end 
		def PLOC2D_convertPose(PoseFromPLOC): #Function to convert the frames from a list with millimiters, and RPY angles in degrees data (as returned by PLOC2D_) to a pose variable (meters, radians, axis angle notation) as used by the UR robot. INPUT=list (length 6) with frame format from PLOC2D_ (mm, RPY angles in degrees). OUTPUT=UR robot pose. 
			PLOC2D_rotRPY=[0,0,0] 
			PLOC2D_rotRPY[0]=d2r(PoseFromPLOC[5])  #Rx 
			PLOC2D_rotRPY[1]=d2r(PoseFromPLOC[6])  #Ry 
			PLOC2D_rotRPY[2]=d2r(PoseFromPLOC[7])  #Rz 
			PLOC2D_rotVec=rpy2rotvec(PLOC2D_rotRPY) 
			PLOC2D_convertedPose=p[PoseFromPLOC[2]/1000,PoseFromPLOC[3]/1000,PoseFromPLOC[4]/1000,PLOC2D_rotVec[0],PLOC2D_rotVec[1],PLOC2D_rotVec[2]] 
			return PLOC2D_convertedPose 
		end 
		def PLOC2D_LocatePart(PLOC2D_command): #Function to ask PLOC2D_ to locate a part. INPUT= string PLOC2D_ job Alias. OUTPUT=list with received part result data 
			#PLOC2D_command = "Run.Locate,1" 
           PLOC2D_located = "Run.Locate.Ok" 
			#textmsg("sent",PLOC2D_command) 
			PLOC2D_SendString(PLOC2D_command) 
       	#sleep(0.2) 
			PLOC2D_receivedPartMsg=socket_read_string("Sick_Ploc_Socket","","",False,120) 
					#textmsg(PLOC2D_receivedPartMsg) 
			PLOC2D_delimiter = "," 
			PLOC2D_l=0 
			l_token =0 
			PLOC2D_ok=-1 
			PLOC2D_data=[0,0,0,0,0,0,0,0,0] 
			PLOC2D_pos=0 
			PLOC2D_token=" " 
			s_length = str_len(PLOC2D_receivedPartMsg) 
			first=True 
			while PLOC2D_ok!= 0: 
				PLOC2D_pos = str_find(PLOC2D_receivedPartMsg,PLOC2D_delimiter) 
				if PLOC2D_pos==-1: 
					PLOC2D_token = PLOC2D_receivedPartMsg 
					PLOC2D_ok=0 
					#textmsg(PLOC2D_data) 
				else: 
					PLOC2D_token = str_sub(PLOC2D_receivedPartMsg,0,PLOC2D_pos) 
					l_token = str_len(PLOC2D_token) 
					PLOC2D_receivedPartMsg=str_sub(PLOC2D_receivedPartMsg,l_token+1,s_length) 
				end 
				if first: 
					first=False 
					if PLOC2D_token == PLOC2D_located: 
						PLOC2D_data[0]=1 
					else: 
						PLOC2D_data[0]=0 
						break 
					end 
				end 
				if PLOC2D_l == 1: 
					PLOC2D_data[1] = to_num(PLOC2D_token) 
				elif PLOC2D_l == 4: 
					PLOC2D_data[2] = to_num(PLOC2D_token) 
				elif PLOC2D_l == 5: 
					PLOC2D_data[3] = to_num(PLOC2D_token) 
				elif PLOC2D_l == 6: 
					PLOC2D_data[4] = to_num(PLOC2D_token) 
				elif PLOC2D_l == 7: 
					PLOC2D_data[5] = to_num(PLOC2D_token) 
				elif PLOC2D_l == 8: 
					PLOC2D_data[6] = to_num(PLOC2D_token) 
				elif PLOC2D_l == 9: 
					PLOC2D_data[7] = to_num(PLOC2D_token) 
				elif PLOC2D_l == 3: 
					PLOC2D_data[8] = to_num(PLOC2D_token) 
				end 
				PLOC2D_l=PLOC2D_l+1 
			end 
			return PLOC2D_data 
		end 
		def PLOC2D_extractPose(PLOC2D_PartData):  #Function extracting a meaningful pose from the part result data obtained from PLOC. 
			PLOC2D_correctionFrame=PLOC2D_PartData 
			PLOC2D_correctionFrame[2]=PLOC2D_PartData[2]/1 
			PLOC2D_correctionFrame[3]=PLOC2D_PartData[3]/1 
			PLOC2D_correctionFrame[4]=PLOC2D_PartData[4]/1 
			PLOC2D_URPose=PLOC2D_convertPose(PLOC2D_correctionFrame) 
			return PLOC2D_URPose 
		end 
		def PLOC2D_getCorrectedPickPose(PLOC2D_PartData,PLOC_AlignmentF): 
			PLOC2D_correctionFrame=PLOC2D_extractPose(PLOC2D_PartData) 
			PLOC2D_correctedFrame=pose_trans(PLOC_AlignmentF,PLOC2D_correctionFrame) 
			#textmsg(PLOC2D_correctedFrame) 
			return PLOC2D_correctedFrame 
		end 
		def Connect_To_ANYFEEDER(PLOC2D_ip,PLOC2D_port): #Function to establish socket connection with PLOC 
			PLOC2D_AnyfeederConnected = False 
			PLOC2D_AnyfeederCounter=0 
			while not PLOC2D_AnyfeederConnected and (PLOC2D_AnyfeederCounter<100): 
	  			PLOC2D_AnyfeederConnected=socket_open(PLOC2D_ip,PLOC2D_port,"Anyfeeder_Socket") 
	  			PLOC2D_AnyfeederCounter=PLOC2D_AnyfeederCounter+1 
			end 
			if PLOC2D_AnyfeederCounter>=100: 
	  			popup("Connection to anyfeeder failed","Time out",False,True,blocking=True) 
	  			halt 
			else: 
	  			#textmsg("Connected to Anyfeeder") 
				ANYFEEDER_CONNECTION = "Connected to Anyfeeder" 			end 
		end	 
		def Connect_To_PLOC(PLOC2D_ip,PLOC2D_port): #Function to establish socket connection with PLOC 
			PLOC2D_Connected = False 
			PLOC2D_counter=0 
			while not PLOC2D_Connected and (PLOC2D_counter<100): 
	  			PLOC2D_Connected=socket_open(PLOC2D_ip,PLOC2D_port,"Sick_Ploc_Socket") 
	  			PLOC2D_counter=PLOC2D_counter+1 
			end 
			if PLOC2D_counter>=100: 
	  			popup("Connection to PLOC failed","Time out",False,True,blocking=True) 
	  			halt 
			else: 
	  			#textmsg("Connected to PLOC") 
				PLOC2D_CONNECTION = "Connected to PLOC2D_" 			end 
		end	 
		def DISCONNECT_To_PLOC(): #Function to disconnect socket connection with PLOC 
			socket_close("Sick_Ploc_Socket") 
		end	 
		def DISCONNECT_To_ANYFEEDER(): #Function to disconnect socket connection with PLOC 
			socket_close("Anyfeeder_Socket") 
		end	 
		def PLOC2D_sendToAnyfeed(PLOC2D_AnyfeederCommand): #Function to ask PLOC2D_ to locate a part. INPUT= string PLOC2D_ job Alias. OUTPUT=list with received part result data 
			PLOC2D_SendStringToAnyfeeder(PLOC2D_AnyfeederCommand) 
       	#sleep(0.2) 
			PLOC2D_AnyfeederReceivedPartMsg=socket_read_string("Anyfeeder_Socket","","",False,120) 
			#textmsg(PLOC2D_AnyfeederReceivedPartMsg) 
			return PLOC2D_AnyfeederReceivedPartMsg 
		end	 
  # end: URCap Installation Node
  $ 1 "BeforeStart"
  $ 2 "open_socket≔socket_open('192.168.65.102',50000,'ur5e_pc')"
  global open_socket=socket_open("192.168.65.102",50000,"ur5e_pc")
  $ 3 "Loop open_socket≟ False "
  while (open_socket ==   False  ):
    $ 4 "open_socket≔socket_open('192.168.65.102',50000,'ur5e_pc')"
    global open_socket=socket_open("192.168.65.102",50000,"ur5e_pc")
  end
  while (True):
    $ 5 "Robot Program"
    $ 8 "If open_socket≟ True "
    if (open_socket ==   True  ):
      $ 9 "string"
      $ 10 "'read string'"
      # 'read string'
      $ 11 "str≔socket_read_string('ur5e_pc')"
      global str=socket_read_string("ur5e_pc")
      $ 12 "Loop str≟''"
      while (str == ""):
        $ 13 "str≔socket_read_string('ur5e_pc')"
        global str=socket_read_string("ur5e_pc")
        $ 14 "Wait: 0.01"
        sleep(0.01)
      end
      $ 15 "'send string'"
      # 'send string'
      $ 16 "was_send≔socket_send_string('ACK','ur5e_pc')"
      global was_send=socket_send_string("ACK","ur5e_pc")
      $ 17 "Loop was_send≟ False "
      while (was_send ==   False  ):
        $ 18 "was_send≔socket_send_string('ACK','ur5e_pc')"
        global was_send=socket_send_string("ACK","ur5e_pc")
        $ 19 "Wait: 0.01"
        sleep(0.01)
      end
      $ 20 "Wait: 0.01"
      sleep(0.01)
      $ 21 "integer"
      $ 22 "'read int'"
      # 'read int'
      $ 23 "data≔socket_read_binary_integer(1,'ur5e_pc')"
      global data=socket_read_binary_integer(1,"ur5e_pc")
      $ 24 "Loop data[0]≟0"
      while (data[0] == 0):
        $ 25 "data≔socket_read_binary_integer(1,'ur5e_pc')"
        global data=socket_read_binary_integer(1,"ur5e_pc")
        $ 26 "Wait: 0.01"
        sleep(0.01)
      end
      $ 27 "'send int'"
      # 'send int'
      $ 28 "was_send≔socket_send_int(9,'ur5e_pc')"
      global was_send=socket_send_int(9,"ur5e_pc")
      $ 29 "Loop was_send≟ False "
      while (was_send ==   False  ):
        $ 30 "was_send≔socket_send_int(9,'ur5e_pc')"
        global was_send=socket_send_int(9,"ur5e_pc")
        $ 31 "Wait: 0.01"
        sleep(0.01)
      end
      $ 32 "Wait: 0.01"
      sleep(0.01)
      $ 33 "integer array"
      $ 34 "'read Int array'"
      # 'read Int array'
      $ 35 "array_size≔3"
      global array_size=3
      $ 36 "data3≔socket_read_binary_integer(array_size,'ur5e_pc')"
      global data3=socket_read_binary_integer(array_size,"ur5e_pc")
      $ 37 "Loop data3[0]≟0"
      while (data3[0] == 0):
        $ 38 "data3≔socket_read_binary_integer(array_size,'ur5e_pc')"
        global data3=socket_read_binary_integer(array_size,"ur5e_pc")
        $ 39 "Wait: 0.01"
        sleep(0.01)
      end
      $ 40 "'send int array'"
      # 'send int array'
      $ 41 "int_array≔[4, 5, 6]"
      global int_array=[4, 5, 6]
      $ 42 "str_int≔to_str(int_array)"
      global str_int=to_str(int_array)
      $ 43 "was_send≔socket_send_string(str_int,'ur5e_pc')"
      global was_send=socket_send_string(str_int,"ur5e_pc")
      $ 44 "Loop was_send≟ False "
      while (was_send ==   False  ):
        $ 45 "was_send≔socket_send_string(str_int,'ur5e_pc')"
        global was_send=socket_send_string(str_int,"ur5e_pc")
        $ 46 "Wait: 0.01"
        sleep(0.01)
      end
      $ 47 "Wait: 0.01"
      sleep(0.01)
      $ 48 "float"
      $ 49 "'get one float'"
      # 'get one float'
      $ 50 "data4≔socket_read_ascii_float(1,'ur5e_pc')"
      global data4=socket_read_ascii_float(1,"ur5e_pc")
      $ 51 "Loop data4[0]≟0"
      while (data4[0] == 0):
        $ 52 "data4≔socket_read_ascii_float(1,'ur5e_pc')"
        global data4=socket_read_ascii_float(1,"ur5e_pc")
        $ 53 "Wait: 0.01"
        sleep(0.01)
      end
      $ 54 "'send array of floats'"
      # 'send array of floats'
      $ 55 "send_floats≔8.8"
      global send_floats=8.8
      $ 56 "str_floats≔to_str(send_floats)"
      global str_floats=to_str(send_floats)
      $ 57 "was_send≔socket_send_string(str_floats,'ur5e_pc')"
      global was_send=socket_send_string(str_floats,"ur5e_pc")
      $ 58 "Loop was_send≟ False "
      while (was_send ==   False  ):
        $ 59 "was_send≔socket_send_string(str_floats,'ur5e_pc')"
        global was_send=socket_send_string(str_floats,"ur5e_pc")
        $ 60 "Wait: 0.01"
        sleep(0.01)
      end
      $ 61 "float array"
      $ 62 "'get array of floats'"
      # 'get array of floats'
      $ 63 "data2≔socket_read_ascii_float(3,'ur5e_pc')"
      global data2=socket_read_ascii_float(3,"ur5e_pc")
      $ 64 "Loop data2[0]≟0"
      while (data2[0] == 0):
        $ 65 "data2≔socket_read_ascii_float(3,'ur5e_pc')"
        global data2=socket_read_ascii_float(3,"ur5e_pc")
        $ 66 "Wait: 0.01"
        sleep(0.01)
      end
      $ 67 "'send array of floats'"
      # 'send array of floats'
      $ 68 "send_floats2≔[4.4, 5.5, 6.6]"
      global send_floats2=[4.4, 5.5, 6.6]
      $ 69 "str_floats≔to_str(send_floats2)"
      global str_floats=to_str(send_floats2)
      $ 70 "was_send≔socket_send_string(str_floats,'ur5e_pc')"
      global was_send=socket_send_string(str_floats,"ur5e_pc")
      $ 71 "Loop was_send≟ False "
      while (was_send ==   False  ):
        $ 72 "was_send≔socket_send_string(str_floats,'ur5e_pc')"
        global was_send=socket_send_string(str_floats,"ur5e_pc")
        $ 73 "Wait: 0.01"
        sleep(0.01)
      end
      $ 74 "socket_close('ur5e_pc')"
      socket_close("ur5e_pc")
      $ 75 "Halt"
      halt
    end
  end
end
